// This file is @generated by syn-internal-codegen.
// It is not intended for manual editing.

#![allow(unused_variables)]
#[cfg(any(feature = "full", feature = "derive"))]
use crate::gen::helper::visit_mut::*;
#[cfg(any(feature = "full", feature = "derive"))]
use crate::punctuated::Punctuated;
use crate::*;
use proc_macro2::Span;
#[cfg(feature = "full")]
macro_rules! full {
    ($e:expr) => {
        $e
    };
}
#[cfg(all(feature = "derive", not(feature = "full")))]
macro_rules! full {
    ($e:expr) => {
        unreachable!()
    };
}
macro_rules! skip {
    ($($tt:tt)*) => {};
}
/// Syntax tree traversal to mutate an exclusive borrow of a syntax tree in
/// place.
///
/// See the [module documentation] for details.
///
/// [module documentation]: self
///
/// *This trait is available only if Syn is built with the `"visit-mut"` feature.*
pub trait VisitMut {
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_abi_mut(&mut self, i: &mut Abi) {
        visit_abi_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_angle_bracketed_generic_arguments_mut(
        &mut self,
        i: &mut AngleBracketedGenericArguments,
    ) {
        visit_angle_bracketed_generic_arguments_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_arm_mut(&mut self, i: &mut Arm) {
        visit_arm_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_attr_style_mut(&mut self, i: &mut AttrStyle) {
        visit_attr_style_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_attribute_mut(&mut self, i: &mut Attribute) {
        visit_attribute_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_bare_fn_arg_mut(&mut self, i: &mut BareFnArg) {
        visit_bare_fn_arg_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_bin_op_mut(&mut self, i: &mut BinOp) {
        visit_bin_op_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_binding_mut(&mut self, i: &mut Binding) {
        visit_binding_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_block_mut(&mut self, i: &mut Block) {
        visit_block_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_bound_lifetimes_mut(&mut self, i: &mut BoundLifetimes) {
        visit_bound_lifetimes_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_const_param_mut(&mut self, i: &mut ConstParam) {
        visit_const_param_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_constraint_mut(&mut self, i: &mut Constraint) {
        visit_constraint_mut(self, i)
    }
    #[cfg(feature = "derive")]
    fn visit_data_mut(&mut self, i: &mut Data) {
        visit_data_mut(self, i)
    }
    #[cfg(feature = "derive")]
    fn visit_data_enum_mut(&mut self, i: &mut DataEnum) {
        visit_data_enum_mut(self, i)
    }
    #[cfg(feature = "derive")]
    fn visit_data_struct_mut(&mut self, i: &mut DataStruct) {
        visit_data_struct_mut(self, i)
    }
    #[cfg(feature = "derive")]
    fn visit_data_union_mut(&mut self, i: &mut DataUnion) {
        visit_data_union_mut(self, i)
    }
    #[cfg(feature = "derive")]
    fn visit_derive_input_mut(&mut self, i: &mut DeriveInput) {
        visit_derive_input_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_expr_mut(&mut self, i: &mut Expr) {
        visit_expr_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_expr_array_mut(&mut self, i: &mut ExprArray) {
        visit_expr_array_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_expr_assign_mut(&mut self, i: &mut ExprAssign) {
        visit_expr_assign_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_expr_assign_op_mut(&mut self, i: &mut ExprAssignOp) {
        visit_expr_assign_op_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_expr_async_mut(&mut self, i: &mut ExprAsync) {
        visit_expr_async_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_expr_await_mut(&mut self, i: &mut ExprAwait) {
        visit_expr_await_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_expr_binary_mut(&mut self, i: &mut ExprBinary) {
        visit_expr_binary_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_expr_block_mut(&mut self, i: &mut ExprBlock) {
        visit_expr_block_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_expr_box_mut(&mut self, i: &mut ExprBox) {
        visit_expr_box_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_expr_break_mut(&mut self, i: &mut ExprBreak) {
        visit_expr_break_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_expr_call_mut(&mut self, i: &mut ExprCall) {
        visit_expr_call_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_expr_cast_mut(&mut self, i: &mut ExprCast) {
        visit_expr_cast_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_expr_closure_mut(&mut self, i: &mut ExprClosure) {
        visit_expr_closure_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_expr_continue_mut(&mut self, i: &mut ExprContinue) {
        visit_expr_continue_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_expr_field_mut(&mut self, i: &mut ExprField) {
        visit_expr_field_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_expr_for_loop_mut(&mut self, i: &mut ExprForLoop) {
        visit_expr_for_loop_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_expr_group_mut(&mut self, i: &mut ExprGroup) {
        visit_expr_group_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_expr_if_mut(&mut self, i: &mut ExprIf) {
        visit_expr_if_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_expr_index_mut(&mut self, i: &mut ExprIndex) {
        visit_expr_index_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_expr_let_mut(&mut self, i: &mut ExprLet) {
        visit_expr_let_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_expr_lit_mut(&mut self, i: &mut ExprLit) {
        visit_expr_lit_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_expr_loop_mut(&mut self, i: &mut ExprLoop) {
        visit_expr_loop_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_expr_macro_mut(&mut self, i: &mut ExprMacro) {
        visit_expr_macro_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_expr_match_mut(&mut self, i: &mut ExprMatch) {
        visit_expr_match_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_expr_method_call_mut(&mut self, i: &mut ExprMethodCall) {
        visit_expr_method_call_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_expr_paren_mut(&mut self, i: &mut ExprParen) {
        visit_expr_paren_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_expr_path_mut(&mut self, i: &mut ExprPath) {
        visit_expr_path_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_expr_range_mut(&mut self, i: &mut ExprRange) {
        visit_expr_range_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_expr_reference_mut(&mut self, i: &mut ExprReference) {
        visit_expr_reference_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_expr_repeat_mut(&mut self, i: &mut ExprRepeat) {
        visit_expr_repeat_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_expr_return_mut(&mut self, i: &mut ExprReturn) {
        visit_expr_return_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_expr_struct_mut(&mut self, i: &mut ExprStruct) {
        visit_expr_struct_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_expr_try_mut(&mut self, i: &mut ExprTry) {
        visit_expr_try_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_expr_try_block_mut(&mut self, i: &mut ExprTryBlock) {
        visit_expr_try_block_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_expr_tuple_mut(&mut self, i: &mut ExprTuple) {
        visit_expr_tuple_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_expr_type_mut(&mut self, i: &mut ExprType) {
        visit_expr_type_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_expr_unary_mut(&mut self, i: &mut ExprUnary) {
        visit_expr_unary_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_expr_unsafe_mut(&mut self, i: &mut ExprUnsafe) {
        visit_expr_unsafe_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_expr_while_mut(&mut self, i: &mut ExprWhile) {
        visit_expr_while_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_expr_yield_mut(&mut self, i: &mut ExprYield) {
        visit_expr_yield_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_field_mut(&mut self, i: &mut Field) {
        visit_field_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_field_pat_mut(&mut self, i: &mut FieldPat) {
        visit_field_pat_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_field_value_mut(&mut self, i: &mut FieldValue) {
        visit_field_value_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_fields_mut(&mut self, i: &mut Fields) {
        visit_fields_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_fields_named_mut(&mut self, i: &mut FieldsNamed) {
        visit_fields_named_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_fields_unnamed_mut(&mut self, i: &mut FieldsUnnamed) {
        visit_fields_unnamed_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_file_mut(&mut self, i: &mut File) {
        visit_file_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_fn_arg_mut(&mut self, i: &mut FnArg) {
        visit_fn_arg_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_foreign_item_mut(&mut self, i: &mut ForeignItem) {
        visit_foreign_item_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_foreign_item_fn_mut(&mut self, i: &mut ForeignItemFn) {
        visit_foreign_item_fn_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_foreign_item_macro_mut(&mut self, i: &mut ForeignItemMacro) {
        visit_foreign_item_macro_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_foreign_item_static_mut(&mut self, i: &mut ForeignItemStatic) {
        visit_foreign_item_static_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_foreign_item_type_mut(&mut self, i: &mut ForeignItemType) {
        visit_foreign_item_type_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_generic_argument_mut(&mut self, i: &mut GenericArgument) {
        visit_generic_argument_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_generic_method_argument_mut(&mut self, i: &mut GenericMethodArgument) {
        visit_generic_method_argument_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_generic_param_mut(&mut self, i: &mut GenericParam) {
        visit_generic_param_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_generics_mut(&mut self, i: &mut Generics) {
        visit_generics_mut(self, i)
    }
    fn visit_ident_mut(&mut self, i: &mut Ident) {
        visit_ident_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_impl_item_mut(&mut self, i: &mut ImplItem) {
        visit_impl_item_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_impl_item_const_mut(&mut self, i: &mut ImplItemConst) {
        visit_impl_item_const_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_impl_item_macro_mut(&mut self, i: &mut ImplItemMacro) {
        visit_impl_item_macro_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_impl_item_method_mut(&mut self, i: &mut ImplItemMethod) {
        visit_impl_item_method_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_impl_item_type_mut(&mut self, i: &mut ImplItemType) {
        visit_impl_item_type_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_index_mut(&mut self, i: &mut Index) {
        visit_index_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_item_mut(&mut self, i: &mut Item) {
        visit_item_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_item_const_mut(&mut self, i: &mut ItemConst) {
        visit_item_const_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_item_enum_mut(&mut self, i: &mut ItemEnum) {
        visit_item_enum_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_item_extern_crate_mut(&mut self, i: &mut ItemExternCrate) {
        visit_item_extern_crate_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_item_fn_mut(&mut self, i: &mut ItemFn) {
        visit_item_fn_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_item_foreign_mod_mut(&mut self, i: &mut ItemForeignMod) {
        visit_item_foreign_mod_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_item_impl_mut(&mut self, i: &mut ItemImpl) {
        visit_item_impl_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_item_macro_mut(&mut self, i: &mut ItemMacro) {
        visit_item_macro_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_item_macro2_mut(&mut self, i: &mut ItemMacro2) {
        visit_item_macro2_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_item_mod_mut(&mut self, i: &mut ItemMod) {
        visit_item_mod_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_item_static_mut(&mut self, i: &mut ItemStatic) {
        visit_item_static_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_item_struct_mut(&mut self, i: &mut ItemStruct) {
        visit_item_struct_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_item_trait_mut(&mut self, i: &mut ItemTrait) {
        visit_item_trait_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_item_trait_alias_mut(&mut self, i: &mut ItemTraitAlias) {
        visit_item_trait_alias_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_item_type_mut(&mut self, i: &mut ItemType) {
        visit_item_type_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_item_union_mut(&mut self, i: &mut ItemUnion) {
        visit_item_union_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_item_use_mut(&mut self, i: &mut ItemUse) {
        visit_item_use_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_label_mut(&mut self, i: &mut Label) {
        visit_label_mut(self, i)
    }
    fn visit_lifetime_mut(&mut self, i: &mut Lifetime) {
        visit_lifetime_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_lifetime_def_mut(&mut self, i: &mut LifetimeDef) {
        visit_lifetime_def_mut(self, i)
    }
    fn visit_lit_mut(&mut self, i: &mut Lit) {
        visit_lit_mut(self, i)
    }
    fn visit_lit_bool_mut(&mut self, i: &mut LitBool) {
        visit_lit_bool_mut(self, i)
    }
    fn visit_lit_byte_mut(&mut self, i: &mut LitByte) {
        visit_lit_byte_mut(self, i)
    }
    fn visit_lit_byte_str_mut(&mut self, i: &mut LitByteStr) {
        visit_lit_byte_str_mut(self, i)
    }
    fn visit_lit_char_mut(&mut self, i: &mut LitChar) {
        visit_lit_char_mut(self, i)
    }
    fn visit_lit_float_mut(&mut self, i: &mut LitFloat) {
        visit_lit_float_mut(self, i)
    }
    fn visit_lit_int_mut(&mut self, i: &mut LitInt) {
        visit_lit_int_mut(self, i)
    }
    fn visit_lit_str_mut(&mut self, i: &mut LitStr) {
        visit_lit_str_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_local_mut(&mut self, i: &mut Local) {
        visit_local_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_macro_mut(&mut self, i: &mut Macro) {
        visit_macro_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_macro_delimiter_mut(&mut self, i: &mut MacroDelimiter) {
        visit_macro_delimiter_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_member_mut(&mut self, i: &mut Member) {
        visit_member_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_meta_mut(&mut self, i: &mut Meta) {
        visit_meta_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_meta_list_mut(&mut self, i: &mut MetaList) {
        visit_meta_list_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_meta_name_value_mut(&mut self, i: &mut MetaNameValue) {
        visit_meta_name_value_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_method_turbofish_mut(&mut self, i: &mut MethodTurbofish) {
        visit_method_turbofish_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_nested_meta_mut(&mut self, i: &mut NestedMeta) {
        visit_nested_meta_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_parenthesized_generic_arguments_mut(&mut self, i: &mut ParenthesizedGenericArguments) {
        visit_parenthesized_generic_arguments_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_pat_mut(&mut self, i: &mut Pat) {
        visit_pat_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_pat_box_mut(&mut self, i: &mut PatBox) {
        visit_pat_box_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_pat_ident_mut(&mut self, i: &mut PatIdent) {
        visit_pat_ident_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_pat_lit_mut(&mut self, i: &mut PatLit) {
        visit_pat_lit_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_pat_macro_mut(&mut self, i: &mut PatMacro) {
        visit_pat_macro_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_pat_or_mut(&mut self, i: &mut PatOr) {
        visit_pat_or_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_pat_path_mut(&mut self, i: &mut PatPath) {
        visit_pat_path_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_pat_range_mut(&mut self, i: &mut PatRange) {
        visit_pat_range_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_pat_reference_mut(&mut self, i: &mut PatReference) {
        visit_pat_reference_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_pat_rest_mut(&mut self, i: &mut PatRest) {
        visit_pat_rest_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_pat_slice_mut(&mut self, i: &mut PatSlice) {
        visit_pat_slice_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_pat_struct_mut(&mut self, i: &mut PatStruct) {
        visit_pat_struct_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_pat_tuple_mut(&mut self, i: &mut PatTuple) {
        visit_pat_tuple_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_pat_tuple_struct_mut(&mut self, i: &mut PatTupleStruct) {
        visit_pat_tuple_struct_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_pat_type_mut(&mut self, i: &mut PatType) {
        visit_pat_type_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_pat_wild_mut(&mut self, i: &mut PatWild) {
        visit_pat_wild_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_path_mut(&mut self, i: &mut Path) {
        visit_path_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_path_arguments_mut(&mut self, i: &mut PathArguments) {
        visit_path_arguments_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_path_segment_mut(&mut self, i: &mut PathSegment) {
        visit_path_segment_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_predicate_eq_mut(&mut self, i: &mut PredicateEq) {
        visit_predicate_eq_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_predicate_lifetime_mut(&mut self, i: &mut PredicateLifetime) {
        visit_predicate_lifetime_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_predicate_type_mut(&mut self, i: &mut PredicateType) {
        visit_predicate_type_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_qself_mut(&mut self, i: &mut QSelf) {
        visit_qself_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_range_limits_mut(&mut self, i: &mut RangeLimits) {
        visit_range_limits_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_receiver_mut(&mut self, i: &mut Receiver) {
        visit_receiver_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_return_type_mut(&mut self, i: &mut ReturnType) {
        visit_return_type_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_signature_mut(&mut self, i: &mut Signature) {
        visit_signature_mut(self, i)
    }
    fn visit_span_mut(&mut self, i: &mut Span) {
        visit_span_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_stmt_mut(&mut self, i: &mut Stmt) {
        visit_stmt_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_trait_bound_mut(&mut self, i: &mut TraitBound) {
        visit_trait_bound_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_trait_bound_modifier_mut(&mut self, i: &mut TraitBoundModifier) {
        visit_trait_bound_modifier_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_trait_item_mut(&mut self, i: &mut TraitItem) {
        visit_trait_item_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_trait_item_const_mut(&mut self, i: &mut TraitItemConst) {
        visit_trait_item_const_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_trait_item_macro_mut(&mut self, i: &mut TraitItemMacro) {
        visit_trait_item_macro_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_trait_item_method_mut(&mut self, i: &mut TraitItemMethod) {
        visit_trait_item_method_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_trait_item_type_mut(&mut self, i: &mut TraitItemType) {
        visit_trait_item_type_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_type_mut(&mut self, i: &mut Type) {
        visit_type_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_type_array_mut(&mut self, i: &mut TypeArray) {
        visit_type_array_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_type_bare_fn_mut(&mut self, i: &mut TypeBareFn) {
        visit_type_bare_fn_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_type_group_mut(&mut self, i: &mut TypeGroup) {
        visit_type_group_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_type_impl_trait_mut(&mut self, i: &mut TypeImplTrait) {
        visit_type_impl_trait_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_type_infer_mut(&mut self, i: &mut TypeInfer) {
        visit_type_infer_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_type_macro_mut(&mut self, i: &mut TypeMacro) {
        visit_type_macro_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_type_never_mut(&mut self, i: &mut TypeNever) {
        visit_type_never_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_type_param_mut(&mut self, i: &mut TypeParam) {
        visit_type_param_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_type_param_bound_mut(&mut self, i: &mut TypeParamBound) {
        visit_type_param_bound_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_type_paren_mut(&mut self, i: &mut TypeParen) {
        visit_type_paren_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_type_path_mut(&mut self, i: &mut TypePath) {
        visit_type_path_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_type_ptr_mut(&mut self, i: &mut TypePtr) {
        visit_type_ptr_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_type_reference_mut(&mut self, i: &mut TypeReference) {
        visit_type_reference_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_type_slice_mut(&mut self, i: &mut TypeSlice) {
        visit_type_slice_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_type_trait_object_mut(&mut self, i: &mut TypeTraitObject) {
        visit_type_trait_object_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_type_tuple_mut(&mut self, i: &mut TypeTuple) {
        visit_type_tuple_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_un_op_mut(&mut self, i: &mut UnOp) {
        visit_un_op_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_use_glob_mut(&mut self, i: &mut UseGlob) {
        visit_use_glob_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_use_group_mut(&mut self, i: &mut UseGroup) {
        visit_use_group_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_use_name_mut(&mut self, i: &mut UseName) {
        visit_use_name_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_use_path_mut(&mut self, i: &mut UsePath) {
        visit_use_path_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_use_rename_mut(&mut self, i: &mut UseRename) {
        visit_use_rename_mut(self, i)
    }
    #[cfg(feature = "full")]
    fn visit_use_tree_mut(&mut self, i: &mut UseTree) {
        visit_use_tree_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_variadic_mut(&mut self, i: &mut Variadic) {
        visit_variadic_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_variant_mut(&mut self, i: &mut Variant) {
        visit_variant_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_vis_crate_mut(&mut self, i: &mut VisCrate) {
        visit_vis_crate_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_vis_public_mut(&mut self, i: &mut VisPublic) {
        visit_vis_public_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_vis_restricted_mut(&mut self, i: &mut VisRestricted) {
        visit_vis_restricted_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_visibility_mut(&mut self, i: &mut Visibility) {
        visit_visibility_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_where_clause_mut(&mut self, i: &mut WhereClause) {
        visit_where_clause_mut(self, i)
    }
    #[cfg(any(feature = "derive", feature = "full"))]
    fn visit_where_predicate_mut(&mut self, i: &mut WherePredicate) {
        visit_where_predicate_mut(self, i)
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_abi_mut<V>(v: &mut V, node: &mut Abi)
where
    V: VisitMut + ?Sized,
{
    tokens_helper(v, &mut node.extern_token.span);
    if let Some(it) = &mut node.name {
        v.visit_lit_str_mut(it)
    };
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_angle_bracketed_generic_arguments_mut<V>(
    v: &mut V,
    node: &mut AngleBracketedGenericArguments,
) where
    V: VisitMut + ?Sized,
{
    if let Some(it) = &mut node.colon2_token {
        tokens_helper(v, &mut it.spans)
    };
    tokens_helper(v, &mut node.lt_token.spans);
    for el in Punctuated::pairs_mut(&mut node.args) {
        let (it, p) = el.into_tuple();
        v.visit_generic_argument_mut(it);
        if let Some(p) = p {
            tokens_helper(v, &mut p.spans);
        }
    }
    tokens_helper(v, &mut node.gt_token.spans);
}
#[cfg(feature = "full")]
pub fn visit_arm_mut<V>(v: &mut V, node: &mut Arm)
where
    V: VisitMut + ?Sized,
{
    for it in &mut node.attrs {
        v.visit_attribute_mut(it)
    }
    v.visit_pat_mut(&mut node.pat);
    if let Some(it) = &mut node.guard {
        tokens_helper(v, &mut (it).0.span);
        v.visit_expr_mut(&mut *(it).1);
    };
    tokens_helper(v, &mut node.fat_arrow_token.spans);
    v.visit_expr_mut(&mut *node.body);
    if let Some(it) = &mut node.comma {
        tokens_helper(v, &mut it.spans)
    };
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_attr_style_mut<V>(v: &mut V, node: &mut AttrStyle)
where
    V: VisitMut + ?Sized,
{
    match node {
        AttrStyle::Outer => {}
        AttrStyle::Inner(_binding_0) => {
            tokens_helper(v, &mut _binding_0.spans);
        }
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_attribute_mut<V>(v: &mut V, node: &mut Attribute)
where
    V: VisitMut + ?Sized,
{
    tokens_helper(v, &mut node.pound_token.spans);
    v.visit_attr_style_mut(&mut node.style);
    tokens_helper(v, &mut node.bracket_token.span);
    v.visit_path_mut(&mut node.path);
    skip!(node.tokens);
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_bare_fn_arg_mut<V>(v: &mut V, node: &mut BareFnArg)
where
    V: VisitMut + ?Sized,
{
    for it in &mut node.attrs {
        v.visit_attribute_mut(it)
    }
    if let Some(it) = &mut node.name {
        v.visit_ident_mut(&mut (it).0);
        tokens_helper(v, &mut (it).1.spans);
    };
    v.visit_type_mut(&mut node.ty);
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_bin_op_mut<V>(v: &mut V, node: &mut BinOp)
where
    V: VisitMut + ?Sized,
{
    match node {
        BinOp::Add(_binding_0) => {
            tokens_helper(v, &mut _binding_0.spans);
        }
        BinOp::Sub(_binding_0) => {
            tokens_helper(v, &mut _binding_0.spans);
        }
        BinOp::Mul(_binding_0) => {
            tokens_helper(v, &mut _binding_0.spans);
        }
        BinOp::Div(_binding_0) => {
            tokens_helper(v, &mut _binding_0.spans);
        }
        BinOp::Rem(_binding_0) => {
            tokens_helper(v, &mut _binding_0.spans);
        }
        BinOp::And(_binding_0) => {
            tokens_helper(v, &mut _binding_0.spans);
        }
        BinOp::Or(_binding_0) => {
            tokens_helper(v, &mut _binding_0.spans);
        }
        BinOp::BitXor(_binding_0) => {
            tokens_helper(v, &mut _binding_0.spans);
        }
        BinOp::BitAnd(_binding_0) => {
            tokens_helper(v, &mut _binding_0.spans);
        }
        BinOp::BitOr(_binding_0) => {
            tokens_helper(v, &mut _binding_0.spans);
        }
        BinOp::Shl(_binding_0) => {
            tokens_helper(v, &mut _binding_0.spans);
        }
        BinOp::Shr(_binding_0) => {
            tokens_helper(v, &mut _binding_0.spans);
        }
        BinOp::Eq(_binding_0) => {
            tokens_helper(v, &mut _binding_0.spans);
        }
        BinOp::Lt(_binding_0) => {
            tokens_helper(v, &mut _binding_0.spans);
        }
        BinOp::Le(_binding_0) => {
            tokens_helper(v, &mut _binding_0.spans);
        }
        BinOp::Ne(_binding_0) => {
            tokens_helper(v, &mut _binding_0.spans);
        }
        BinOp::Ge(_binding_0) => {
            tokens_helper(v, &mut _binding_0.spans);
        }
        BinOp::Gt(_binding_0) => {
            tokens_helper(v, &mut _binding_0.spans);
        }
        BinOp::AddEq(_binding_0) => {
            tokens_helper(v, &mut _binding_0.spans);
        }
        BinOp::SubEq(_binding_0) => {
            tokens_helper(v, &mut _binding_0.spans);
        }
        BinOp::MulEq(_binding_0) => {
            tokens_helper(v, &mut _binding_0.spans);
        }
        BinOp::DivEq(_binding_0) => {
            tokens_helper(v, &mut _binding_0.spans);
        }
        BinOp::RemEq(_binding_0) => {
            tokens_helper(v, &mut _binding_0.spans);
        }
        BinOp::BitXorEq(_binding_0) => {
            tokens_helper(v, &mut _binding_0.spans);
        }
        BinOp::BitAndEq(_binding_0) => {
            tokens_helper(v, &mut _binding_0.spans);
        }
        BinOp::BitOrEq(_binding_0) => {
            tokens_helper(v, &mut _binding_0.spans);
        }
        BinOp::ShlEq(_binding_0) => {
            tokens_helper(v, &mut _binding_0.spans);
        }
        BinOp::ShrEq(_binding_0) => {
            tokens_helper(v, &mut _binding_0.spans);
        }
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_binding_mut<V>(v: &mut V, node: &mut Binding)
where
    V: VisitMut + ?Sized,
{
    v.visit_ident_mut(&mut node.ident);
    tokens_helper(v, &mut node.eq_token.spans);
    v.visit_type_mut(&mut node.ty);
}
#[cfg(feature = "full")]
pub fn visit_block_mut<V>(v: &mut V, node: &mut Block)
where
    V: VisitMut + ?Sized,
{
    tokens_helper(v, &mut node.brace_token.span);
    for it in &mut node.stmts {
        v.visit_stmt_mut(it)
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_bound_lifetimes_mut<V>(v: &mut V, node: &mut BoundLifetimes)
where
    V: VisitMut + ?Sized,
{
    tokens_helper(v, &mut node.for_token.span);
    tokens_helper(v, &mut node.lt_token.spans);
    for el in Punctuated::pairs_mut(&mut node.lifetimes) {
        let (it, p) = el.into_tuple();
        v.visit_lifetime_def_mut(it);
        if let Some(p) = p {
            tokens_helper(v, &mut p.spans);
        }
    }
    tokens_helper(v, &mut node.gt_token.spans);
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_const_param_mut<V>(v: &mut V, node: &mut ConstParam)
where
    V: VisitMut + ?Sized,
{
    for it in &mut node.attrs {
        v.visit_attribute_mut(it)
    }
    tokens_helper(v, &mut node.const_token.span);
    v.visit_ident_mut(&mut node.ident);
    tokens_helper(v, &mut node.colon_token.spans);
    v.visit_type_mut(&mut node.ty);
    if let Some(it) = &mut node.eq_token {
        tokens_helper(v, &mut it.spans)
    };
    if let Some(it) = &mut node.default {
        v.visit_expr_mut(it)
    };
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_constraint_mut<V>(v: &mut V, node: &mut Constraint)
where
    V: VisitMut + ?Sized,
{
    v.visit_ident_mut(&mut node.ident);
    tokens_helper(v, &mut node.colon_token.spans);
    for el in Punctuated::pairs_mut(&mut node.bounds) {
        let (it, p) = el.into_tuple();
        v.visit_type_param_bound_mut(it);
        if let Some(p) = p {
            tokens_helper(v, &mut p.spans);
        }
    }
}
#[cfg(feature = "derive")]
pub fn visit_data_mut<V>(v: &mut V, node: &mut Data)
where
    V: VisitMut + ?Sized,
{
    match node {
        Data::Struct(_binding_0) => {
            v.visit_data_struct_mut(_binding_0);
        }
        Data::Enum(_binding_0) => {
            v.visit_data_enum_mut(_binding_0);
        }
        Data::Union(_binding_0) => {
            v.visit_data_union_mut(_binding_0);
        }
    }
}
#[cfg(feature = "derive")]
pub fn visit_data_enum_mut<V>(v: &mut V, node: &mut DataEnum)
where
    V: VisitMut + ?Sized,
{
    tokens_helper(v, &mut node.enum_token.span);
    tokens_helper(v, &mut node.brace_token.span);
    for el in Punctuated::pairs_mut(&mut node.variants) {
        let (it, p) = el.into_tuple();
        v.visit_variant_mut(it);
        if let Some(p) = p {
            tokens_helper(v, &mut p.spans);
        }
    }
}
#[cfg(feature = "derive")]
pub fn visit_data_struct_mut<V>(v: &mut V, node: &mut DataStruct)
where
    V: VisitMut + ?Sized,
{
    tokens_helper(v, &mut node.struct_token.span);
    v.visit_fields_mut(&mut node.fields);
    if let Some(it) = &mut node.semi_token {
        tokens_helper(v, &mut it.spans)
    };
}
#[cfg(feature = "derive")]
pub fn visit_data_union_mut<V>(v: &mut V, node: &mut DataUnion)
where
    V: VisitMut + ?Sized,
{
    tokens_helper(v, &mut node.union_token.span);
    v.visit_fields_named_mut(&mut node.fields);
}
#[cfg(feature = "derive")]
pub fn visit_derive_input_mut<V>(v: &mut V, node: &mut DeriveInput)
where
    V: VisitMut + ?Sized,
{
    for it in &mut node.attrs {
        v.visit_attribute_mut(it)
    }
    v.visit_visibility_mut(&mut node.vis);
    v.visit_ident_mut(&mut node.ident);
    v.visit_generics_mut(&mut node.generics);
    v.visit_data_mut(&mut node.data);
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_expr_mut<V>(v: &mut V, node: &mut Expr)
where
    V: VisitMut + ?Sized,
{
    match node {
        Expr::Array(_binding_0) => {
            full!(v.visit_expr_array_mut(_binding_0));
        }
        Expr::Assign(_binding_0) => {
            full!(v.visit_expr_assign_mut(_binding_0));
        }
        Expr::AssignOp(_binding_0) => {
            full!(v.visit_expr_assign_op_mut(_binding_0));
        }
        Expr::Async(_binding_0) => {
            full!(v.visit_expr_async_mut(_binding_0));
        }
        Expr::Await(_binding_0) => {
            full!(v.visit_expr_await_mut(_binding_0));
        }
        Expr::Binary(_binding_0) => {
            v.visit_expr_binary_mut(_binding_0);
        }
        Expr::Block(_binding_0) => {
            full!(v.visit_expr_block_mut(_binding_0));
        }
        Expr::Box(_binding_0) => {
            full!(v.visit_expr_box_mut(_binding_0));
        }
        Expr::Break(_binding_0) => {
            full!(v.visit_expr_break_mut(_binding_0));
        }
        Expr::Call(_binding_0) => {
            v.visit_expr_call_mut(_binding_0);
        }
        Expr::Cast(_binding_0) => {
            v.visit_expr_cast_mut(_binding_0);
        }
        Expr::Closure(_binding_0) => {
            full!(v.visit_expr_closure_mut(_binding_0));
        }
        Expr::Continue(_binding_0) => {
            full!(v.visit_expr_continue_mut(_binding_0));
        }
        Expr::Field(_binding_0) => {
            v.visit_expr_field_mut(_binding_0);
        }
        Expr::ForLoop(_binding_0) => {
            full!(v.visit_expr_for_loop_mut(_binding_0));
        }
        Expr::Group(_binding_0) => {
            full!(v.visit_expr_group_mut(_binding_0));
        }
        Expr::If(_binding_0) => {
            full!(v.visit_expr_if_mut(_binding_0));
        }
        Expr::Index(_binding_0) => {
            v.visit_expr_index_mut(_binding_0);
        }
        Expr::Let(_binding_0) => {
            full!(v.visit_expr_let_mut(_binding_0));
        }
        Expr::Lit(_binding_0) => {
            v.visit_expr_lit_mut(_binding_0);
        }
        Expr::Loop(_binding_0) => {
            full!(v.visit_expr_loop_mut(_binding_0));
        }
        Expr::Macro(_binding_0) => {
            full!(v.visit_expr_macro_mut(_binding_0));
        }
        Expr::Match(_binding_0) => {
            full!(v.visit_expr_match_mut(_binding_0));
        }
        Expr::MethodCall(_binding_0) => {
            full!(v.visit_expr_method_call_mut(_binding_0));
        }
        Expr::Paren(_binding_0) => {
            v.visit_expr_paren_mut(_binding_0);
        }
        Expr::Path(_binding_0) => {
            v.visit_expr_path_mut(_binding_0);
        }
        Expr::Range(_binding_0) => {
            full!(v.visit_expr_range_mut(_binding_0));
        }
        Expr::Reference(_binding_0) => {
            full!(v.visit_expr_reference_mut(_binding_0));
        }
        Expr::Repeat(_binding_0) => {
            full!(v.visit_expr_repeat_mut(_binding_0));
        }
        Expr::Return(_binding_0) => {
            full!(v.visit_expr_return_mut(_binding_0));
        }
        Expr::Struct(_binding_0) => {
            full!(v.visit_expr_struct_mut(_binding_0));
        }
        Expr::Try(_binding_0) => {
            full!(v.visit_expr_try_mut(_binding_0));
        }
        Expr::TryBlock(_binding_0) => {
            full!(v.visit_expr_try_block_mut(_binding_0));
        }
        Expr::Tuple(_binding_0) => {
            full!(v.visit_expr_tuple_mut(_binding_0));
        }
        Expr::Type(_binding_0) => {
            full!(v.visit_expr_type_mut(_binding_0));
        }
        Expr::Unary(_binding_0) => {
            v.visit_expr_unary_mut(_binding_0);
        }
        Expr::Unsafe(_binding_0) => {
            full!(v.visit_expr_unsafe_mut(_binding_0));
        }
        Expr::Verbatim(_binding_0) => {
            skip!(_binding_0);
        }
        Expr::While(_binding_0) => {
            full!(v.visit_expr_while_mut(_binding_0));
        }
        Expr::Yield(_binding_0) => {
            full!(v.visit_expr_yield_mut(_binding_0));
        }
        _ => unreachable!(),
    }
}
#[cfg(feature = "full")]
pub fn visit_expr_array_mut<V>(v: &mut V, node: &mut ExprArray)
where
    V: VisitMut + ?Sized,
{
    for it in &mut node.attrs {
        v.visit_attribute_mut(it)
    }
    tokens_helper(v, &mut node.bracket_token.span);
    for el in Punctuated::pairs_mut(&mut node.elems) {
        let (it, p) = el.into_tuple();
        v.visit_expr_mut(it);
        if let Some(p) = p {
            tokens_helper(v, &mut p.spans);
        }
    }
}
#[cfg(feature = "full")]
pub fn visit_expr_assign_mut<V>(v: &mut V, node: &mut ExprAssign)
where
    V: VisitMut + ?Sized,
{
    for it in &mut node.attrs {
        v.visit_attribute_mut(it)
    }
    v.visit_expr_mut(&mut *node.left);
    tokens_helper(v, &mut node.eq_token.spans);
    v.visit_expr_mut(&mut *node.right);
}
#[cfg(feature = "full")]
pub fn visit_expr_assign_op_mut<V>(v: &mut V, node: &mut ExprAssignOp)
where
    V: VisitMut + ?Sized,
{
    for it in &mut node.attrs {
        v.visit_attribute_mut(it)
    }
    v.visit_expr_mut(&mut *node.left);
    v.visit_bin_op_mut(&mut node.op);
    v.visit_expr_mut(&mut *node.right);
}
#[cfg(feature = "full")]
pub fn visit_expr_async_mut<V>(v: &mut V, node: &mut ExprAsync)
where
    V: VisitMut + ?Sized,
{
    for it in &mut node.attrs {
        v.visit_attribute_mut(it)
    }
    tokens_helper(v, &mut node.async_token.span);
    if let Some(it) = &mut node.capture {
        tokens_helper(v, &mut it.span)
    };
    v.visit_block_mut(&mut node.block);
}
#[cfg(feature = "full")]
pub fn visit_expr_await_mut<V>(v: &mut V, node: &mut ExprAwait)
where
    V: VisitMut + ?Sized,
{
    for it in &mut node.attrs {
        v.visit_attribute_mut(it)
    }
    v.visit_expr_mut(&mut *node.base);
    tokens_helper(v, &mut node.dot_token.spans);
    tokens_helper(v, &mut node.await_token.span);
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_expr_binary_mut<V>(v: &mut V, node: &mut ExprBinary)
where
    V: VisitMut + ?Sized,
{
    for it in &mut node.attrs {
        v.visit_attribute_mut(it)
    }
    v.visit_expr_mut(&mut *node.left);
    v.visit_bin_op_mut(&mut node.op);
    v.visit_expr_mut(&mut *node.right);
}
#[cfg(feature = "full")]
pub fn visit_expr_block_mut<V>(v: &mut V, node: &mut ExprBlock)
where
    V: VisitMut + ?Sized,
{
    for it in &mut node.attrs {
        v.visit_attribute_mut(it)
    }
    if let Some(it) = &mut node.label {
        v.visit_label_mut(it)
    };
    v.visit_block_mut(&mut node.block);
}
#[cfg(feature = "full")]
pub fn visit_expr_box_mut<V>(v: &mut V, node: &mut ExprBox)
where
    V: VisitMut + ?Sized,
{
    for it in &mut node.attrs {
        v.visit_attribute_mut(it)
    }
    tokens_helper(v, &mut node.box_token.span);
    v.visit_expr_mut(&mut *node.expr);
}
#[cfg(feature = "full")]
pub fn visit_expr_break_mut<V>(v: &mut V, node: &mut ExprBreak)
where
    V: VisitMut + ?Sized,
{
    for it in &mut node.attrs {
        v.visit_attribute_mut(it)
    }
    tokens_helper(v, &mut node.break_token.span);
    if let Some(it) = &mut node.label {
        v.visit_lifetime_mut(it)
    };
    if let Some(it) = &mut node.expr {
        v.visit_expr_mut(&mut **it)
    };
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_expr_call_mut<V>(v: &mut V, node: &mut ExprCall)
where
    V: VisitMut + ?Sized,
{
    for it in &mut node.attrs {
        v.visit_attribute_mut(it)
    }
    v.visit_expr_mut(&mut *node.func);
    tokens_helper(v, &mut node.paren_token.span);
    for el in Punctuated::pairs_mut(&mut node.args) {
        let (it, p) = el.into_tuple();
        v.visit_expr_mut(it);
        if let Some(p) = p {
            tokens_helper(v, &mut p.spans);
        }
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_expr_cast_mut<V>(v: &mut V, node: &mut ExprCast)
where
    V: VisitMut + ?Sized,
{
    for it in &mut node.attrs {
        v.visit_attribute_mut(it)
    }
    v.visit_expr_mut(&mut *node.expr);
    tokens_helper(v, &mut node.as_token.span);
    v.visit_type_mut(&mut *node.ty);
}
#[cfg(feature = "full")]
pub fn visit_expr_closure_mut<V>(v: &mut V, node: &mut ExprClosure)
where
    V: VisitMut + ?Sized,
{
    for it in &mut node.attrs {
        v.visit_attribute_mut(it)
    }
    if let Some(it) = &mut node.asyncness {
        tokens_helper(v, &mut it.span)
    };
    if let Some(it) = &mut node.movability {
        tokens_helper(v, &mut it.span)
    };
    if let Some(it) = &mut node.capture {
        tokens_helper(v, &mut it.span)
    };
    tokens_helper(v, &mut node.or1_token.spans);
    for el in Punctuated::pairs_mut(&mut node.inputs) {
        let (it, p) = el.into_tuple();
        v.visit_pat_mut(it);
        if let Some(p) = p {
            tokens_helper(v, &mut p.spans);
        }
    }
    tokens_helper(v, &mut node.or2_token.spans);
    v.visit_return_type_mut(&mut node.output);
    v.visit_expr_mut(&mut *node.body);
}
#[cfg(feature = "full")]
pub fn visit_expr_continue_mut<V>(v: &mut V, node: &mut ExprContinue)
where
    V: VisitMut + ?Sized,
{
    for it in &mut node.attrs {
        v.visit_attribute_mut(it)
    }
    tokens_helper(v, &mut node.continue_token.span);
    if let Some(it) = &mut node.label {
        v.visit_lifetime_mut(it)
    };
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_expr_field_mut<V>(v: &mut V, node: &mut ExprField)
where
    V: VisitMut + ?Sized,
{
    for it in &mut node.attrs {
        v.visit_attribute_mut(it)
    }
    v.visit_expr_mut(&mut *node.base);
    tokens_helper(v, &mut node.dot_token.spans);
    v.visit_member_mut(&mut node.member);
}
#[cfg(feature = "full")]
pub fn visit_expr_for_loop_mut<V>(v: &mut V, node: &mut ExprForLoop)
where
    V: VisitMut + ?Sized,
{
    for it in &mut node.attrs {
        v.visit_attribute_mut(it)
    }
    if let Some(it) = &mut node.label {
        v.visit_label_mut(it)
    };
    tokens_helper(v, &mut node.for_token.span);
    v.visit_pat_mut(&mut node.pat);
    tokens_helper(v, &mut node.in_token.span);
    v.visit_expr_mut(&mut *node.expr);
    v.visit_block_mut(&mut node.body);
}
#[cfg(feature = "full")]
pub fn visit_expr_group_mut<V>(v: &mut V, node: &mut ExprGroup)
where
    V: VisitMut + ?Sized,
{
    for it in &mut node.attrs {
        v.visit_attribute_mut(it)
    }
    tokens_helper(v, &mut node.group_token.span);
    v.visit_expr_mut(&mut *node.expr);
}
#[cfg(feature = "full")]
pub fn visit_expr_if_mut<V>(v: &mut V, node: &mut ExprIf)
where
    V: VisitMut + ?Sized,
{
    for it in &mut node.attrs {
        v.visit_attribute_mut(it)
    }
    tokens_helper(v, &mut node.if_token.span);
    v.visit_expr_mut(&mut *node.cond);
    v.visit_block_mut(&mut node.then_branch);
    if let Some(it) = &mut node.else_branch {
        tokens_helper(v, &mut (it).0.span);
        v.visit_expr_mut(&mut *(it).1);
    };
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_expr_index_mut<V>(v: &mut V, node: &mut ExprIndex)
where
    V: VisitMut + ?Sized,
{
    for it in &mut node.attrs {
        v.visit_attribute_mut(it)
    }
    v.visit_expr_mut(&mut *node.expr);
    tokens_helper(v, &mut node.bracket_token.span);
    v.visit_expr_mut(&mut *node.index);
}
#[cfg(feature = "full")]
pub fn visit_expr_let_mut<V>(v: &mut V, node: &mut ExprLet)
where
    V: VisitMut + ?Sized,
{
    for it in &mut node.attrs {
        v.visit_attribute_mut(it)
    }
    tokens_helper(v, &mut node.let_token.span);
    v.visit_pat_mut(&mut node.pat);
    tokens_helper(v, &mut node.eq_token.spans);
    v.visit_expr_mut(&mut *node.expr);
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_expr_lit_mut<V>(v: &mut V, node: &mut ExprLit)
where
    V: VisitMut + ?Sized,
{
    for it in &mut node.attrs {
        v.visit_attribute_mut(it)
    }
    v.visit_lit_mut(&mut node.lit);
}
#[cfg(feature = "full")]
pub fn visit_expr_loop_mut<V>(v: &mut V, node: &mut ExprLoop)
where
    V: VisitMut + ?Sized,
{
    for it in &mut node.attrs {
        v.visit_attribute_mut(it)
    }
    if let Some(it) = &mut node.label {
        v.visit_label_mut(it)
    };
    tokens_helper(v, &mut node.loop_token.span);
    v.visit_block_mut(&mut node.body);
}
#[cfg(feature = "full")]
pub fn visit_expr_macro_mut<V>(v: &mut V, node: &mut ExprMacro)
where
    V: VisitMut + ?Sized,
{
    for it in &mut node.attrs {
        v.visit_attribute_mut(it)
    }
    v.visit_macro_mut(&mut node.mac);
}
#[cfg(feature = "full")]
pub fn visit_expr_match_mut<V>(v: &mut V, node: &mut ExprMatch)
where
    V: VisitMut + ?Sized,
{
    for it in &mut node.attrs {
        v.visit_attribute_mut(it)
    }
    tokens_helper(v, &mut node.match_token.span);
    v.visit_expr_mut(&mut *node.expr);
    tokens_helper(v, &mut node.brace_token.span);
    for it in &mut node.arms {
        v.visit_arm_mut(it)
    }
}
#[cfg(feature = "full")]
pub fn visit_expr_method_call_mut<V>(v: &mut V, node: &mut ExprMethodCall)
where
    V: VisitMut + ?Sized,
{
    for it in &mut node.attrs {
        v.visit_attribute_mut(it)
    }
    v.visit_expr_mut(&mut *node.receiver);
    tokens_helper(v, &mut node.dot_token.spans);
    v.visit_ident_mut(&mut node.method);
    if let Some(it) = &mut node.turbofish {
        v.visit_method_turbofish_mut(it)
    };
    tokens_helper(v, &mut node.paren_token.span);
    for el in Punctuated::pairs_mut(&mut node.args) {
        let (it, p) = el.into_tuple();
        v.visit_expr_mut(it);
        if let Some(p) = p {
            tokens_helper(v, &mut p.spans);
        }
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_expr_paren_mut<V>(v: &mut V, node: &mut ExprParen)
where
    V: VisitMut + ?Sized,
{
    for it in &mut node.attrs {
        v.visit_attribute_mut(it)
    }
    tokens_helper(v, &mut node.paren_token.span);
    v.visit_expr_mut(&mut *node.expr);
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_expr_path_mut<V>(v: &mut V, node: &mut ExprPath)
where
    V: VisitMut + ?Sized,
{
    for it in &mut node.attrs {
        v.visit_attribute_mut(it)
    }
    if let Some(it) = &mut node.qself {
        v.visit_qself_mut(it)
    };
    v.visit_path_mut(&mut node.path);
}
#[cfg(feature = "full")]
pub fn visit_expr_range_mut<V>(v: &mut V, node: &mut ExprRange)
where
    V: VisitMut + ?Sized,
{
    for it in &mut node.attrs {
        v.visit_attribute_mut(it)
    }
    if let Some(it) = &mut node.from {
        v.visit_expr_mut(&mut **it)
    };
    v.visit_range_limits_mut(&mut node.limits);
    if let Some(it) = &mut node.to {
        v.visit_expr_mut(&mut **it)
    };
}
#[cfg(feature = "full")]
pub fn visit_expr_reference_mut<V>(v: &mut V, node: &mut ExprReference)
where
    V: VisitMut + ?Sized,
{
    for it in &mut node.attrs {
        v.visit_attribute_mut(it)
    }
    tokens_helper(v, &mut node.and_token.spans);
    if let Some(it) = &mut node.mutability {
        tokens_helper(v, &mut it.span)
    };
    v.visit_expr_mut(&mut *node.expr);
}
#[cfg(feature = "full")]
pub fn visit_expr_repeat_mut<V>(v: &mut V, node: &mut ExprRepeat)
where
    V: VisitMut + ?Sized,
{
    for it in &mut node.attrs {
        v.visit_attribute_mut(it)
    }
    tokens_helper(v, &mut node.bracket_token.span);
    v.visit_expr_mut(&mut *node.expr);
    tokens_helper(v, &mut node.semi_token.spans);
    v.visit_expr_mut(&mut *node.len);
}
#[cfg(feature = "full")]
pub fn visit_expr_return_mut<V>(v: &mut V, node: &mut ExprReturn)
where
    V: VisitMut + ?Sized,
{
    for it in &mut node.attrs {
        v.visit_attribute_mut(it)
    }
    tokens_helper(v, &mut node.return_token.span);
    if let Some(it) = &mut node.expr {
        v.visit_expr_mut(&mut **it)
    };
}
#[cfg(feature = "full")]
pub fn visit_expr_struct_mut<V>(v: &mut V, node: &mut ExprStruct)
where
    V: VisitMut + ?Sized,
{
    for it in &mut node.attrs {
        v.visit_attribute_mut(it)
    }
    v.visit_path_mut(&mut node.path);
    tokens_helper(v, &mut node.brace_token.span);
    for el in Punctuated::pairs_mut(&mut node.fields) {
        let (it, p) = el.into_tuple();
        v.visit_field_value_mut(it);
        if let Some(p) = p {
            tokens_helper(v, &mut p.spans);
        }
    }
    if let Some(it) = &mut node.dot2_token {
        tokens_helper(v, &mut it.spans)
    };
    if let Some(it) = &mut node.rest {
        v.visit_expr_mut(&mut **it)
    };
}
#[cfg(feature = "full")]
pub fn visit_expr_try_mut<V>(v: &mut V, node: &mut ExprTry)
where
    V: VisitMut + ?Sized,
{
    for it in &mut node.attrs {
        v.visit_attribute_mut(it)
    }
    v.visit_expr_mut(&mut *node.expr);
    tokens_helper(v, &mut node.question_token.spans);
}
#[cfg(feature = "full")]
pub fn visit_expr_try_block_mut<V>(v: &mut V, node: &mut ExprTryBlock)
where
    V: VisitMut + ?Sized,
{
    for it in &mut node.attrs {
        v.visit_attribute_mut(it)
    }
    tokens_helper(v, &mut node.try_token.span);
    v.visit_block_mut(&mut node.block);
}
#[cfg(feature = "full")]
pub fn visit_expr_tuple_mut<V>(v: &mut V, node: &mut ExprTuple)
where
    V: VisitMut + ?Sized,
{
    for it in &mut node.attrs {
        v.visit_attribute_mut(it)
    }
    tokens_helper(v, &mut node.paren_token.span);
    for el in Punctuated::pairs_mut(&mut node.elems) {
        let (it, p) = el.into_tuple();
        v.visit_expr_mut(it);
        if let Some(p) = p {
            tokens_helper(v, &mut p.spans);
        }
    }
}
#[cfg(feature = "full")]
pub fn visit_expr_type_mut<V>(v: &mut V, node: &mut ExprType)
where
    V: VisitMut + ?Sized,
{
    for it in &mut node.attrs {
        v.visit_attribute_mut(it)
    }
    v.visit_expr_mut(&mut *node.expr);
    tokens_helper(v, &mut node.colon_token.spans);
    v.visit_type_mut(&mut *node.ty);
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_expr_unary_mut<V>(v: &mut V, node: &mut ExprUnary)
where
    V: VisitMut + ?Sized,
{
    for it in &mut node.attrs {
        v.visit_attribute_mut(it)
    }
    v.visit_un_op_mut(&mut node.op);
    v.visit_expr_mut(&mut *node.expr);
}
#[cfg(feature = "full")]
pub fn visit_expr_unsafe_mut<V>(v: &mut V, node: &mut ExprUnsafe)
where
    V: VisitMut + ?Sized,
{
    for it in &mut node.attrs {
        v.visit_attribute_mut(it)
    }
    tokens_helper(v, &mut node.unsafe_token.span);
    v.visit_block_mut(&mut node.block);
}
#[cfg(feature = "full")]
pub fn visit_expr_while_mut<V>(v: &mut V, node: &mut ExprWhile)
where
    V: VisitMut + ?Sized,
{
    for it in &mut node.attrs {
        v.visit_attribute_mut(it)
    }
    if let Some(it) = &mut node.label {
        v.visit_label_mut(it)
    };
    tokens_helper(v, &mut node.while_token.span);
    v.visit_expr_mut(&mut *node.cond);
    v.visit_block_mut(&mut node.body);
}
#[cfg(feature = "full")]
pub fn visit_expr_yield_mut<V>(v: &mut V, node: &mut ExprYield)
where
    V: VisitMut + ?Sized,
{
    for it in &mut node.attrs {
        v.visit_attribute_mut(it)
    }
    tokens_helper(v, &mut node.yield_token.span);
    if let Some(it) = &mut node.expr {
        v.visit_expr_mut(&mut **it)
    };
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_field_mut<V>(v: &mut V, node: &mut Field)
where
    V: VisitMut + ?Sized,
{
    for it in &mut node.attrs {
        v.visit_attribute_mut(it)
    }
    v.visit_visibility_mut(&mut node.vis);
    if let Some(it) = &mut node.ident {
        v.visit_ident_mut(it)
    };
    if let Some(it) = &mut node.colon_token {
        tokens_helper(v, &mut it.spans)
    };
    v.visit_type_mut(&mut node.ty);
}
#[cfg(feature = "full")]
pub fn visit_field_pat_mut<V>(v: &mut V, node: &mut FieldPat)
where
    V: VisitMut + ?Sized,
{
    for it in &mut node.attrs {
        v.visit_attribute_mut(it)
    }
    v.visit_member_mut(&mut node.member);
    if let Some(it) = &mut node.colon_token {
        tokens_helper(v, &mut it.spans)
    };
    v.visit_pat_mut(&mut *node.pat);
}
#[cfg(feature = "full")]
pub fn visit_field_value_mut<V>(v: &mut V, node: &mut FieldValue)
where
    V: VisitMut + ?Sized,
{
    for it in &mut node.attrs {
        v.visit_attribute_mut(it)
    }
    v.visit_member_mut(&mut node.member);
    if let Some(it) = &mut node.colon_token {
        tokens_helper(v, &mut it.spans)
    };
    v.visit_expr_mut(&mut node.expr);
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_fields_mut<V>(v: &mut V, node: &mut Fields)
where
    V: VisitMut + ?Sized,
{
    match node {
        Fields::Named(_binding_0) => {
            v.visit_fields_named_mut(_binding_0);
        }
        Fields::Unnamed(_binding_0) => {
            v.visit_fields_unnamed_mut(_binding_0);
        }
        Fields::Unit => {}
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_fields_named_mut<V>(v: &mut V, node: &mut FieldsNamed)
where
    V: VisitMut + ?Sized,
{
    tokens_helper(v, &mut node.brace_token.span);
    for el in Punctuated::pairs_mut(&mut node.named) {
        let (it, p) = el.into_tuple();
        v.visit_field_mut(it);
        if let Some(p) = p {
            tokens_helper(v, &mut p.spans);
        }
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_fields_unnamed_mut<V>(v: &mut V, node: &mut FieldsUnnamed)
where
    V: VisitMut + ?Sized,
{
    tokens_helper(v, &mut node.paren_token.span);
    for el in Punctuated::pairs_mut(&mut node.unnamed) {
        let (it, p) = el.into_tuple();
        v.visit_field_mut(it);
        if let Some(p) = p {
            tokens_helper(v, &mut p.spans);
        }
    }
}
#[cfg(feature = "full")]
pub fn visit_file_mut<V>(v: &mut V, node: &mut File)
where
    V: VisitMut + ?Sized,
{
    skip!(node.shebang);
    for it in &mut node.attrs {
        v.visit_attribute_mut(it)
    }
    for it in &mut node.items {
        v.visit_item_mut(it)
    }
}
#[cfg(feature = "full")]
pub fn visit_fn_arg_mut<V>(v: &mut V, node: &mut FnArg)
where
    V: VisitMut + ?Sized,
{
    match node {
        FnArg::Receiver(_binding_0) => {
            v.visit_receiver_mut(_binding_0);
        }
        FnArg::Typed(_binding_0) => {
            v.visit_pat_type_mut(_binding_0);
        }
    }
}
#[cfg(feature = "full")]
pub fn visit_foreign_item_mut<V>(v: &mut V, node: &mut ForeignItem)
where
    V: VisitMut + ?Sized,
{
    match node {
        ForeignItem::Fn(_binding_0) => {
            v.visit_foreign_item_fn_mut(_binding_0);
        }
        ForeignItem::Static(_binding_0) => {
            v.visit_foreign_item_static_mut(_binding_0);
        }
        ForeignItem::Type(_binding_0) => {
            v.visit_foreign_item_type_mut(_binding_0);
        }
        ForeignItem::Macro(_binding_0) => {
            v.visit_foreign_item_macro_mut(_binding_0);
        }
        ForeignItem::Verbatim(_binding_0) => {
            skip!(_binding_0);
        }
        _ => unreachable!(),
    }
}
#[cfg(feature = "full")]
pub fn visit_foreign_item_fn_mut<V>(v: &mut V, node: &mut ForeignItemFn)
where
    V: VisitMut + ?Sized,
{
    for it in &mut node.attrs {
        v.visit_attribute_mut(it)
    }
    v.visit_visibility_mut(&mut node.vis);
    v.visit_signature_mut(&mut node.sig);
    tokens_helper(v, &mut node.semi_token.spans);
}
#[cfg(feature = "full")]
pub fn visit_foreign_item_macro_mut<V>(v: &mut V, node: &mut ForeignItemMacro)
where
    V: VisitMut + ?Sized,
{
    for it in &mut node.attrs {
        v.visit_attribute_mut(it)
    }
    v.visit_macro_mut(&mut node.mac);
    if let Some(it) = &mut node.semi_token {
        tokens_helper(v, &mut it.spans)
    };
}
#[cfg(feature = "full")]
pub fn visit_foreign_item_static_mut<V>(v: &mut V, node: &mut ForeignItemStatic)
where
    V: VisitMut + ?Sized,
{
    for it in &mut node.attrs {
        v.visit_attribute_mut(it)
    }
    v.visit_visibility_mut(&mut node.vis);
    tokens_helper(v, &mut node.static_token.span);
    if let Some(it) = &mut node.mutability {
        tokens_helper(v, &mut it.span)
    };
    v.visit_ident_mut(&mut node.ident);
    tokens_helper(v, &mut node.colon_token.spans);
    v.visit_type_mut(&mut *node.ty);
    tokens_helper(v, &mut node.semi_token.spans);
}
#[cfg(feature = "full")]
pub fn visit_foreign_item_type_mut<V>(v: &mut V, node: &mut ForeignItemType)
where
    V: VisitMut + ?Sized,
{
    for it in &mut node.attrs {
        v.visit_attribute_mut(it)
    }
    v.visit_visibility_mut(&mut node.vis);
    tokens_helper(v, &mut node.type_token.span);
    v.visit_ident_mut(&mut node.ident);
    tokens_helper(v, &mut node.semi_token.spans);
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_generic_argument_mut<V>(v: &mut V, node: &mut GenericArgument)
where
    V: VisitMut + ?Sized,
{
    match node {
        GenericArgument::Lifetime(_binding_0) => {
            v.visit_lifetime_mut(_binding_0);
        }
        GenericArgument::Type(_binding_0) => {
            v.visit_type_mut(_binding_0);
        }
        GenericArgument::Binding(_binding_0) => {
            v.visit_binding_mut(_binding_0);
        }
        GenericArgument::Constraint(_binding_0) => {
            v.visit_constraint_mut(_binding_0);
        }
        GenericArgument::Const(_binding_0) => {
            v.visit_expr_mut(_binding_0);
        }
    }
}
#[cfg(feature = "full")]
pub fn visit_generic_method_argument_mut<V>(v: &mut V, node: &mut GenericMethodArgument)
where
    V: VisitMut + ?Sized,
{
    match node {
        GenericMethodArgument::Type(_binding_0) => {
            v.visit_type_mut(_binding_0);
        }
        GenericMethodArgument::Const(_binding_0) => {
            v.visit_expr_mut(_binding_0);
        }
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_generic_param_mut<V>(v: &mut V, node: &mut GenericParam)
where
    V: VisitMut + ?Sized,
{
    match node {
        GenericParam::Type(_binding_0) => {
            v.visit_type_param_mut(_binding_0);
        }
        GenericParam::Lifetime(_binding_0) => {
            v.visit_lifetime_def_mut(_binding_0);
        }
        GenericParam::Const(_binding_0) => {
            v.visit_const_param_mut(_binding_0);
        }
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_generics_mut<V>(v: &mut V, node: &mut Generics)
where
    V: VisitMut + ?Sized,
{
    if let Some(it) = &mut node.lt_token {
        tokens_helper(v, &mut it.spans)
    };
    for el in Punctuated::pairs_mut(&mut node.params) {
        let (it, p) = el.into_tuple();
        v.visit_generic_param_mut(it);
        if let Some(p) = p {
            tokens_helper(v, &mut p.spans);
        }
    }
    if let Some(it) = &mut node.gt_token {
        tokens_helper(v, &mut it.spans)
    };
    if let Some(it) = &mut node.where_clause {
        v.visit_where_clause_mut(it)
    };
}
pub fn visit_ident_mut<V>(v: &mut V, node: &mut Ident)
where
    V: VisitMut + ?Sized,
{
    let mut span = node.span();
    v.visit_span_mut(&mut span);
    node.set_span(span);
}
#[cfg(feature = "full")]
pub fn visit_impl_item_mut<V>(v: &mut V, node: &mut ImplItem)
where
    V: VisitMut + ?Sized,
{
    match node {
        ImplItem::Const(_binding_0) => {
            v.visit_impl_item_const_mut(_binding_0);
        }
        ImplItem::Method(_binding_0) => {
            v.visit_impl_item_method_mut(_binding_0);
        }
        ImplItem::Type(_binding_0) => {
            v.visit_impl_item_type_mut(_binding_0);
        }
        ImplItem::Macro(_binding_0) => {
            v.visit_impl_item_macro_mut(_binding_0);
        }
        ImplItem::Verbatim(_binding_0) => {
            skip!(_binding_0);
        }
        _ => unreachable!(),
    }
}
#[cfg(feature = "full")]
pub fn visit_impl_item_const_mut<V>(v: &mut V, node: &mut ImplItemConst)
where
    V: VisitMut + ?Sized,
{
    for it in &mut node.attrs {
        v.visit_attribute_mut(it)
    }
    v.visit_visibility_mut(&mut node.vis);
    if let Some(it) = &mut node.defaultness {
        tokens_helper(v, &mut it.span)
    };
    tokens_helper(v, &mut node.const_token.span);
    v.visit_ident_mut(&mut node.ident);
    tokens_helper(v, &mut node.colon_token.spans);
    v.visit_type_mut(&mut node.ty);
    tokens_helper(v, &mut node.eq_token.spans);
    v.visit_expr_mut(&mut node.expr);
    tokens_helper(v, &mut node.semi_token.spans);
}
#[cfg(feature = "full")]
pub fn visit_impl_item_macro_mut<V>(v: &mut V, node: &mut ImplItemMacro)
where
    V: VisitMut + ?Sized,
{
    for it in &mut node.attrs {
        v.visit_attribute_mut(it)
    }
    v.visit_macro_mut(&mut node.mac);
    if let Some(it) = &mut node.semi_token {
        tokens_helper(v, &mut it.spans)
    };
}
#[cfg(feature = "full")]
pub fn visit_impl_item_method_mut<V>(v: &mut V, node: &mut ImplItemMethod)
where
    V: VisitMut + ?Sized,
{
    for it in &mut node.attrs {
        v.visit_attribute_mut(it)
    }
    v.visit_visibility_mut(&mut node.vis);
    if let Some(it) = &mut node.defaultness {
        tokens_helper(v, &mut it.span)
    };
    v.visit_signature_mut(&mut node.sig);
    v.visit_block_mut(&mut node.block);
}
#[cfg(feature = "full")]
pub fn visit_impl_item_type_mut<V>(v: &mut V, node: &mut ImplItemType)
where
    V: VisitMut + ?Sized,
{
    for it in &mut node.attrs {
        v.visit_attribute_mut(it)
    }
    v.visit_visibility_mut(&mut node.vis);
    if let Some(it) = &mut node.defaultness {
        tokens_helper(v, &mut it.span)
    };
    tokens_helper(v, &mut node.type_token.span);
    v.visit_ident_mut(&mut node.ident);
    v.visit_generics_mut(&mut node.generics);
    tokens_helper(v, &mut node.eq_token.spans);
    v.visit_type_mut(&mut node.ty);
    tokens_helper(v, &mut node.semi_token.spans);
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_index_mut<V>(v: &mut V, node: &mut Index)
where
    V: VisitMut + ?Sized,
{
    skip!(node.index);
    v.visit_span_mut(&mut node.span);
}
#[cfg(feature = "full")]
pub fn visit_item_mut<V>(v: &mut V, node: &mut Item)
where
    V: VisitMut + ?Sized,
{
    match node {
        Item::Const(_binding_0) => {
            v.visit_item_const_mut(_binding_0);
        }
        Item::Enum(_binding_0) => {
            v.visit_item_enum_mut(_binding_0);
        }
        Item::ExternCrate(_binding_0) => {
            v.visit_item_extern_crate_mut(_binding_0);
        }
        Item::Fn(_binding_0) => {
            v.visit_item_fn_mut(_binding_0);
        }
        Item::ForeignMod(_binding_0) => {
            v.visit_item_foreign_mod_mut(_binding_0);
        }
        Item::Impl(_binding_0) => {
            v.visit_item_impl_mut(_binding_0);
        }
        Item::Macro(_binding_0) => {
            v.visit_item_macro_mut(_binding_0);
        }
        Item::Macro2(_binding_0) => {
            v.visit_item_macro2_mut(_binding_0);
        }
        Item::Mod(_binding_0) => {
            v.visit_item_mod_mut(_binding_0);
        }
        Item::Static(_binding_0) => {
            v.visit_item_static_mut(_binding_0);
        }
        Item::Struct(_binding_0) => {
            v.visit_item_struct_mut(_binding_0);
        }
        Item::Trait(_binding_0) => {
            v.visit_item_trait_mut(_binding_0);
        }
        Item::TraitAlias(_binding_0) => {
            v.visit_item_trait_alias_mut(_binding_0);
        }
        Item::Type(_binding_0) => {
            v.visit_item_type_mut(_binding_0);
        }
        Item::Union(_binding_0) => {
            v.visit_item_union_mut(_binding_0);
        }
        Item::Use(_binding_0) => {
            v.visit_item_use_mut(_binding_0);
        }
        Item::Verbatim(_binding_0) => {
            skip!(_binding_0);
        }
        _ => unreachable!(),
    }
}
#[cfg(feature = "full")]
pub fn visit_item_const_mut<V>(v: &mut V, node: &mut ItemConst)
where
    V: VisitMut + ?Sized,
{
    for it in &mut node.attrs {
        v.visit_attribute_mut(it)
    }
    v.visit_visibility_mut(&mut node.vis);
    tokens_helper(v, &mut node.const_token.span);
    v.visit_ident_mut(&mut node.ident);
    tokens_helper(v, &mut node.colon_token.spans);
    v.visit_type_mut(&mut *node.ty);
    tokens_helper(v, &mut node.eq_token.spans);
    v.visit_expr_mut(&mut *node.expr);
    tokens_helper(v, &mut node.semi_token.spans);
}
#[cfg(feature = "full")]
pub fn visit_item_enum_mut<V>(v: &mut V, node: &mut ItemEnum)
where
    V: VisitMut + ?Sized,
{
    for it in &mut node.attrs {
        v.visit_attribute_mut(it)
    }
    v.visit_visibility_mut(&mut node.vis);
    tokens_helper(v, &mut node.enum_token.span);
    v.visit_ident_mut(&mut node.ident);
    v.visit_generics_mut(&mut node.generics);
    tokens_helper(v, &mut node.brace_token.span);
    for el in Punctuated::pairs_mut(&mut node.variants) {
        let (it, p) = el.into_tuple();
        v.visit_variant_mut(it);
        if let Some(p) = p {
            tokens_helper(v, &mut p.spans);
        }
    }
}
#[cfg(feature = "full")]
pub fn visit_item_extern_crate_mut<V>(v: &mut V, node: &mut ItemExternCrate)
where
    V: VisitMut + ?Sized,
{
    for it in &mut node.attrs {
        v.visit_attribute_mut(it)
    }
    v.visit_visibility_mut(&mut node.vis);
    tokens_helper(v, &mut node.extern_token.span);
    tokens_helper(v, &mut node.crate_token.span);
    v.visit_ident_mut(&mut node.ident);
    if let Some(it) = &mut node.rename {
        tokens_helper(v, &mut (it).0.span);
        v.visit_ident_mut(&mut (it).1);
    };
    tokens_helper(v, &mut node.semi_token.spans);
}
#[cfg(feature = "full")]
pub fn visit_item_fn_mut<V>(v: &mut V, node: &mut ItemFn)
where
    V: VisitMut + ?Sized,
{
    for it in &mut node.attrs {
        v.visit_attribute_mut(it)
    }
    v.visit_visibility_mut(&mut node.vis);
    v.visit_signature_mut(&mut node.sig);
    v.visit_block_mut(&mut *node.block);
}
#[cfg(feature = "full")]
pub fn visit_item_foreign_mod_mut<V>(v: &mut V, node: &mut ItemForeignMod)
where
    V: VisitMut + ?Sized,
{
    for it in &mut node.attrs {
        v.visit_attribute_mut(it)
    }
    v.visit_abi_mut(&mut node.abi);
    tokens_helper(v, &mut node.brace_token.span);
    for it in &mut node.items {
        v.visit_foreign_item_mut(it)
    }
}
#[cfg(feature = "full")]
pub fn visit_item_impl_mut<V>(v: &mut V, node: &mut ItemImpl)
where
    V: VisitMut + ?Sized,
{
    for it in &mut node.attrs {
        v.visit_attribute_mut(it)
    }
    if let Some(it) = &mut node.defaultness {
        tokens_helper(v, &mut it.span)
    };
    if let Some(it) = &mut node.unsafety {
        tokens_helper(v, &mut it.span)
    };
    tokens_helper(v, &mut node.impl_token.span);
    v.visit_generics_mut(&mut node.generics);
    if let Some(it) = &mut node.trait_ {
        if let Some(it) = &mut (it).0 {
            tokens_helper(v, &mut it.spans)
        };
        v.visit_path_mut(&mut (it).1);
        tokens_helper(v, &mut (it).2.span);
    };
    v.visit_type_mut(&mut *node.self_ty);
    tokens_helper(v, &mut node.brace_token.span);
    for it in &mut node.items {
        v.visit_impl_item_mut(it)
    }
}
#[cfg(feature = "full")]
pub fn visit_item_macro_mut<V>(v: &mut V, node: &mut ItemMacro)
where
    V: VisitMut + ?Sized,
{
    for it in &mut node.attrs {
        v.visit_attribute_mut(it)
    }
    if let Some(it) = &mut node.ident {
        v.visit_ident_mut(it)
    };
    v.visit_macro_mut(&mut node.mac);
    if let Some(it) = &mut node.semi_token {
        tokens_helper(v, &mut it.spans)
    };
}
#[cfg(feature = "full")]
pub fn visit_item_macro2_mut<V>(v: &mut V, node: &mut ItemMacro2)
where
    V: VisitMut + ?Sized,
{
    for it in &mut node.attrs {
        v.visit_attribute_mut(it)
    }
    v.visit_visibility_mut(&mut node.vis);
    tokens_helper(v, &mut node.macro_token.span);
    v.visit_ident_mut(&mut node.ident);
    skip!(node.rules);
}
#[cfg(feature = "full")]
pub fn visit_item_mod_mut<V>(v: &mut V, node: &mut ItemMod)
where
    V: VisitMut + ?Sized,
{
    for it in &mut node.attrs {
        v.visit_attribute_mut(it)
    }
    v.visit_visibility_mut(&mut node.vis);
    tokens_helper(v, &mut node.mod_token.span);
    v.visit_ident_mut(&mut node.ident);
    if let Some(it) = &mut node.content {
        tokens_helper(v, &mut (it).0.span);
        for it in &mut (it).1 {
            v.visit_item_mut(it)
        }
    };
    if let Some(it) = &mut node.semi {
        tokens_helper(v, &mut it.spans)
    };
}
#[cfg(feature = "full")]
pub fn visit_item_static_mut<V>(v: &mut V, node: &mut ItemStatic)
where
    V: VisitMut + ?Sized,
{
    for it in &mut node.attrs {
        v.visit_attribute_mut(it)
    }
    v.visit_visibility_mut(&mut node.vis);
    tokens_helper(v, &mut node.static_token.span);
    if let Some(it) = &mut node.mutability {
        tokens_helper(v, &mut it.span)
    };
    v.visit_ident_mut(&mut node.ident);
    tokens_helper(v, &mut node.colon_token.spans);
    v.visit_type_mut(&mut *node.ty);
    tokens_helper(v, &mut node.eq_token.spans);
    v.visit_expr_mut(&mut *node.expr);
    tokens_helper(v, &mut node.semi_token.spans);
}
#[cfg(feature = "full")]
pub fn visit_item_struct_mut<V>(v: &mut V, node: &mut ItemStruct)
where
    V: VisitMut + ?Sized,
{
    for it in &mut node.attrs {
        v.visit_attribute_mut(it)
    }
    v.visit_visibility_mut(&mut node.vis);
    tokens_helper(v, &mut node.struct_token.span);
    v.visit_ident_mut(&mut node.ident);
    v.visit_generics_mut(&mut node.generics);
    v.visit_fields_mut(&mut node.fields);
    if let Some(it) = &mut node.semi_token {
        tokens_helper(v, &mut it.spans)
    };
}
#[cfg(feature = "full")]
pub fn visit_item_trait_mut<V>(v: &mut V, node: &mut ItemTrait)
where
    V: VisitMut + ?Sized,
{
    for it in &mut node.attrs {
        v.visit_attribute_mut(it)
    }
    v.visit_visibility_mut(&mut node.vis);
    if let Some(it) = &mut node.unsafety {
        tokens_helper(v, &mut it.span)
    };
    if let Some(it) = &mut node.auto_token {
        tokens_helper(v, &mut it.span)
    };
    tokens_helper(v, &mut node.trait_token.span);
    v.visit_ident_mut(&mut node.ident);
    v.visit_generics_mut(&mut node.generics);
    if let Some(it) = &mut node.colon_token {
        tokens_helper(v, &mut it.spans)
    };
    for el in Punctuated::pairs_mut(&mut node.supertraits) {
        let (it, p) = el.into_tuple();
        v.visit_type_param_bound_mut(it);
        if let Some(p) = p {
            tokens_helper(v, &mut p.spans);
        }
    }
    tokens_helper(v, &mut node.brace_token.span);
    for it in &mut node.items {
        v.visit_trait_item_mut(it)
    }
}
#[cfg(feature = "full")]
pub fn visit_item_trait_alias_mut<V>(v: &mut V, node: &mut ItemTraitAlias)
where
    V: VisitMut + ?Sized,
{
    for it in &mut node.attrs {
        v.visit_attribute_mut(it)
    }
    v.visit_visibility_mut(&mut node.vis);
    tokens_helper(v, &mut node.trait_token.span);
    v.visit_ident_mut(&mut node.ident);
    v.visit_generics_mut(&mut node.generics);
    tokens_helper(v, &mut node.eq_token.spans);
    for el in Punctuated::pairs_mut(&mut node.bounds) {
        let (it, p) = el.into_tuple();
        v.visit_type_param_bound_mut(it);
        if let Some(p) = p {
            tokens_helper(v, &mut p.spans);
        }
    }
    tokens_helper(v, &mut node.semi_token.spans);
}
#[cfg(feature = "full")]
pub fn visit_item_type_mut<V>(v: &mut V, node: &mut ItemType)
where
    V: VisitMut + ?Sized,
{
    for it in &mut node.attrs {
        v.visit_attribute_mut(it)
    }
    v.visit_visibility_mut(&mut node.vis);
    tokens_helper(v, &mut node.type_token.span);
    v.visit_ident_mut(&mut node.ident);
    v.visit_generics_mut(&mut node.generics);
    tokens_helper(v, &mut node.eq_token.spans);
    v.visit_type_mut(&mut *node.ty);
    tokens_helper(v, &mut node.semi_token.spans);
}
#[cfg(feature = "full")]
pub fn visit_item_union_mut<V>(v: &mut V, node: &mut ItemUnion)
where
    V: VisitMut + ?Sized,
{
    for it in &mut node.attrs {
        v.visit_attribute_mut(it)
    }
    v.visit_visibility_mut(&mut node.vis);
    tokens_helper(v, &mut node.union_token.span);
    v.visit_ident_mut(&mut node.ident);
    v.visit_generics_mut(&mut node.generics);
    v.visit_fields_named_mut(&mut node.fields);
}
#[cfg(feature = "full")]
pub fn visit_item_use_mut<V>(v: &mut V, node: &mut ItemUse)
where
    V: VisitMut + ?Sized,
{
    for it in &mut node.attrs {
        v.visit_attribute_mut(it)
    }
    v.visit_visibility_mut(&mut node.vis);
    tokens_helper(v, &mut node.use_token.span);
    if let Some(it) = &mut node.leading_colon {
        tokens_helper(v, &mut it.spans)
    };
    v.visit_use_tree_mut(&mut node.tree);
    tokens_helper(v, &mut node.semi_token.spans);
}
#[cfg(feature = "full")]
pub fn visit_label_mut<V>(v: &mut V, node: &mut Label)
where
    V: VisitMut + ?Sized,
{
    v.visit_lifetime_mut(&mut node.name);
    tokens_helper(v, &mut node.colon_token.spans);
}
pub fn visit_lifetime_mut<V>(v: &mut V, node: &mut Lifetime)
where
    V: VisitMut + ?Sized,
{
    v.visit_span_mut(&mut node.apostrophe);
    v.visit_ident_mut(&mut node.ident);
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_lifetime_def_mut<V>(v: &mut V, node: &mut LifetimeDef)
where
    V: VisitMut + ?Sized,
{
    for it in &mut node.attrs {
        v.visit_attribute_mut(it)
    }
    v.visit_lifetime_mut(&mut node.lifetime);
    if let Some(it) = &mut node.colon_token {
        tokens_helper(v, &mut it.spans)
    };
    for el in Punctuated::pairs_mut(&mut node.bounds) {
        let (it, p) = el.into_tuple();
        v.visit_lifetime_mut(it);
        if let Some(p) = p {
            tokens_helper(v, &mut p.spans);
        }
    }
}
pub fn visit_lit_mut<V>(v: &mut V, node: &mut Lit)
where
    V: VisitMut + ?Sized,
{
    match node {
        Lit::Str(_binding_0) => {
            v.visit_lit_str_mut(_binding_0);
        }
        Lit::ByteStr(_binding_0) => {
            v.visit_lit_byte_str_mut(_binding_0);
        }
        Lit::Byte(_binding_0) => {
            v.visit_lit_byte_mut(_binding_0);
        }
        Lit::Char(_binding_0) => {
            v.visit_lit_char_mut(_binding_0);
        }
        Lit::Int(_binding_0) => {
            v.visit_lit_int_mut(_binding_0);
        }
        Lit::Float(_binding_0) => {
            v.visit_lit_float_mut(_binding_0);
        }
        Lit::Bool(_binding_0) => {
            v.visit_lit_bool_mut(_binding_0);
        }
        Lit::Verbatim(_binding_0) => {
            skip!(_binding_0);
        }
    }
}
pub fn visit_lit_bool_mut<V>(v: &mut V, node: &mut LitBool)
where
    V: VisitMut + ?Sized,
{
    skip!(node.value);
    v.visit_span_mut(&mut node.span);
}
pub fn visit_lit_byte_mut<V>(v: &mut V, node: &mut LitByte)
where
    V: VisitMut + ?Sized,
{
}
pub fn visit_lit_byte_str_mut<V>(v: &mut V, node: &mut LitByteStr)
where
    V: VisitMut + ?Sized,
{
}
pub fn visit_lit_char_mut<V>(v: &mut V, node: &mut LitChar)
where
    V: VisitMut + ?Sized,
{
}
pub fn visit_lit_float_mut<V>(v: &mut V, node: &mut LitFloat)
where
    V: VisitMut + ?Sized,
{
}
pub fn visit_lit_int_mut<V>(v: &mut V, node: &mut LitInt)
where
    V: VisitMut + ?Sized,
{
}
pub fn visit_lit_str_mut<V>(v: &mut V, node: &mut LitStr)
where
    V: VisitMut + ?Sized,
{
}
#[cfg(feature = "full")]
pub fn visit_local_mut<V>(v: &mut V, node: &mut Local)
where
    V: VisitMut + ?Sized,
{
    for it in &mut node.attrs {
        v.visit_attribute_mut(it)
    }
    tokens_helper(v, &mut node.let_token.span);
    v.visit_pat_mut(&mut node.pat);
    if let Some(it) = &mut node.init {
        tokens_helper(v, &mut (it).0.spans);
        v.visit_expr_mut(&mut *(it).1);
    };
    tokens_helper(v, &mut node.semi_token.spans);
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_macro_mut<V>(v: &mut V, node: &mut Macro)
where
    V: VisitMut + ?Sized,
{
    v.visit_path_mut(&mut node.path);
    tokens_helper(v, &mut node.bang_token.spans);
    v.visit_macro_delimiter_mut(&mut node.delimiter);
    skip!(node.tokens);
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_macro_delimiter_mut<V>(v: &mut V, node: &mut MacroDelimiter)
where
    V: VisitMut + ?Sized,
{
    match node {
        MacroDelimiter::Paren(_binding_0) => {
            tokens_helper(v, &mut _binding_0.span);
        }
        MacroDelimiter::Brace(_binding_0) => {
            tokens_helper(v, &mut _binding_0.span);
        }
        MacroDelimiter::Bracket(_binding_0) => {
            tokens_helper(v, &mut _binding_0.span);
        }
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_member_mut<V>(v: &mut V, node: &mut Member)
where
    V: VisitMut + ?Sized,
{
    match node {
        Member::Named(_binding_0) => {
            v.visit_ident_mut(_binding_0);
        }
        Member::Unnamed(_binding_0) => {
            v.visit_index_mut(_binding_0);
        }
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_meta_mut<V>(v: &mut V, node: &mut Meta)
where
    V: VisitMut + ?Sized,
{
    match node {
        Meta::Path(_binding_0) => {
            v.visit_path_mut(_binding_0);
        }
        Meta::List(_binding_0) => {
            v.visit_meta_list_mut(_binding_0);
        }
        Meta::NameValue(_binding_0) => {
            v.visit_meta_name_value_mut(_binding_0);
        }
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_meta_list_mut<V>(v: &mut V, node: &mut MetaList)
where
    V: VisitMut + ?Sized,
{
    v.visit_path_mut(&mut node.path);
    tokens_helper(v, &mut node.paren_token.span);
    for el in Punctuated::pairs_mut(&mut node.nested) {
        let (it, p) = el.into_tuple();
        v.visit_nested_meta_mut(it);
        if let Some(p) = p {
            tokens_helper(v, &mut p.spans);
        }
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_meta_name_value_mut<V>(v: &mut V, node: &mut MetaNameValue)
where
    V: VisitMut + ?Sized,
{
    v.visit_path_mut(&mut node.path);
    tokens_helper(v, &mut node.eq_token.spans);
    v.visit_lit_mut(&mut node.lit);
}
#[cfg(feature = "full")]
pub fn visit_method_turbofish_mut<V>(v: &mut V, node: &mut MethodTurbofish)
where
    V: VisitMut + ?Sized,
{
    tokens_helper(v, &mut node.colon2_token.spans);
    tokens_helper(v, &mut node.lt_token.spans);
    for el in Punctuated::pairs_mut(&mut node.args) {
        let (it, p) = el.into_tuple();
        v.visit_generic_method_argument_mut(it);
        if let Some(p) = p {
            tokens_helper(v, &mut p.spans);
        }
    }
    tokens_helper(v, &mut node.gt_token.spans);
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_nested_meta_mut<V>(v: &mut V, node: &mut NestedMeta)
where
    V: VisitMut + ?Sized,
{
    match node {
        NestedMeta::Meta(_binding_0) => {
            v.visit_meta_mut(_binding_0);
        }
        NestedMeta::Lit(_binding_0) => {
            v.visit_lit_mut(_binding_0);
        }
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_parenthesized_generic_arguments_mut<V>(
    v: &mut V,
    node: &mut ParenthesizedGenericArguments,
) where
    V: VisitMut + ?Sized,
{
    tokens_helper(v, &mut node.paren_token.span);
    for el in Punctuated::pairs_mut(&mut node.inputs) {
        let (it, p) = el.into_tuple();
        v.visit_type_mut(it);
        if let Some(p) = p {
            tokens_helper(v, &mut p.spans);
        }
    }
    v.visit_return_type_mut(&mut node.output);
}
#[cfg(feature = "full")]
pub fn visit_pat_mut<V>(v: &mut V, node: &mut Pat)
where
    V: VisitMut + ?Sized,
{
    match node {
        Pat::Box(_binding_0) => {
            v.visit_pat_box_mut(_binding_0);
        }
        Pat::Ident(_binding_0) => {
            v.visit_pat_ident_mut(_binding_0);
        }
        Pat::Lit(_binding_0) => {
            v.visit_pat_lit_mut(_binding_0);
        }
        Pat::Macro(_binding_0) => {
            v.visit_pat_macro_mut(_binding_0);
        }
        Pat::Or(_binding_0) => {
            v.visit_pat_or_mut(_binding_0);
        }
        Pat::Path(_binding_0) => {
            v.visit_pat_path_mut(_binding_0);
        }
        Pat::Range(_binding_0) => {
            v.visit_pat_range_mut(_binding_0);
        }
        Pat::Reference(_binding_0) => {
            v.visit_pat_reference_mut(_binding_0);
        }
        Pat::Rest(_binding_0) => {
            v.visit_pat_rest_mut(_binding_0);
        }
        Pat::Slice(_binding_0) => {
            v.visit_pat_slice_mut(_binding_0);
        }
        Pat::Struct(_binding_0) => {
            v.visit_pat_struct_mut(_binding_0);
        }
        Pat::Tuple(_binding_0) => {
            v.visit_pat_tuple_mut(_binding_0);
        }
        Pat::TupleStruct(_binding_0) => {
            v.visit_pat_tuple_struct_mut(_binding_0);
        }
        Pat::Type(_binding_0) => {
            v.visit_pat_type_mut(_binding_0);
        }
        Pat::Verbatim(_binding_0) => {
            skip!(_binding_0);
        }
        Pat::Wild(_binding_0) => {
            v.visit_pat_wild_mut(_binding_0);
        }
        _ => unreachable!(),
    }
}
#[cfg(feature = "full")]
pub fn visit_pat_box_mut<V>(v: &mut V, node: &mut PatBox)
where
    V: VisitMut + ?Sized,
{
    for it in &mut node.attrs {
        v.visit_attribute_mut(it)
    }
    tokens_helper(v, &mut node.box_token.span);
    v.visit_pat_mut(&mut *node.pat);
}
#[cfg(feature = "full")]
pub fn visit_pat_ident_mut<V>(v: &mut V, node: &mut PatIdent)
where
    V: VisitMut + ?Sized,
{
    for it in &mut node.attrs {
        v.visit_attribute_mut(it)
    }
    if let Some(it) = &mut node.by_ref {
        tokens_helper(v, &mut it.span)
    };
    if let Some(it) = &mut node.mutability {
        tokens_helper(v, &mut it.span)
    };
    v.visit_ident_mut(&mut node.ident);
    if let Some(it) = &mut node.subpat {
        tokens_helper(v, &mut (it).0.spans);
        v.visit_pat_mut(&mut *(it).1);
    };
}
#[cfg(feature = "full")]
pub fn visit_pat_lit_mut<V>(v: &mut V, node: &mut PatLit)
where
    V: VisitMut + ?Sized,
{
    for it in &mut node.attrs {
        v.visit_attribute_mut(it)
    }
    v.visit_expr_mut(&mut *node.expr);
}
#[cfg(feature = "full")]
pub fn visit_pat_macro_mut<V>(v: &mut V, node: &mut PatMacro)
where
    V: VisitMut + ?Sized,
{
    for it in &mut node.attrs {
        v.visit_attribute_mut(it)
    }
    v.visit_macro_mut(&mut node.mac);
}
#[cfg(feature = "full")]
pub fn visit_pat_or_mut<V>(v: &mut V, node: &mut PatOr)
where
    V: VisitMut + ?Sized,
{
    for it in &mut node.attrs {
        v.visit_attribute_mut(it)
    }
    if let Some(it) = &mut node.leading_vert {
        tokens_helper(v, &mut it.spans)
    };
    for el in Punctuated::pairs_mut(&mut node.cases) {
        let (it, p) = el.into_tuple();
        v.visit_pat_mut(it);
        if let Some(p) = p {
            tokens_helper(v, &mut p.spans);
        }
    }
}
#[cfg(feature = "full")]
pub fn visit_pat_path_mut<V>(v: &mut V, node: &mut PatPath)
where
    V: VisitMut + ?Sized,
{
    for it in &mut node.attrs {
        v.visit_attribute_mut(it)
    }
    if let Some(it) = &mut node.qself {
        v.visit_qself_mut(it)
    };
    v.visit_path_mut(&mut node.path);
}
#[cfg(feature = "full")]
pub fn visit_pat_range_mut<V>(v: &mut V, node: &mut PatRange)
where
    V: VisitMut + ?Sized,
{
    for it in &mut node.attrs {
        v.visit_attribute_mut(it)
    }
    v.visit_expr_mut(&mut *node.lo);
    v.visit_range_limits_mut(&mut node.limits);
    v.visit_expr_mut(&mut *node.hi);
}
#[cfg(feature = "full")]
pub fn visit_pat_reference_mut<V>(v: &mut V, node: &mut PatReference)
where
    V: VisitMut + ?Sized,
{
    for it in &mut node.attrs {
        v.visit_attribute_mut(it)
    }
    tokens_helper(v, &mut node.and_token.spans);
    if let Some(it) = &mut node.mutability {
        tokens_helper(v, &mut it.span)
    };
    v.visit_pat_mut(&mut *node.pat);
}
#[cfg(feature = "full")]
pub fn visit_pat_rest_mut<V>(v: &mut V, node: &mut PatRest)
where
    V: VisitMut + ?Sized,
{
    for it in &mut node.attrs {
        v.visit_attribute_mut(it)
    }
    tokens_helper(v, &mut node.dot2_token.spans);
}
#[cfg(feature = "full")]
pub fn visit_pat_slice_mut<V>(v: &mut V, node: &mut PatSlice)
where
    V: VisitMut + ?Sized,
{
    for it in &mut node.attrs {
        v.visit_attribute_mut(it)
    }
    tokens_helper(v, &mut node.bracket_token.span);
    for el in Punctuated::pairs_mut(&mut node.elems) {
        let (it, p) = el.into_tuple();
        v.visit_pat_mut(it);
        if let Some(p) = p {
            tokens_helper(v, &mut p.spans);
        }
    }
}
#[cfg(feature = "full")]
pub fn visit_pat_struct_mut<V>(v: &mut V, node: &mut PatStruct)
where
    V: VisitMut + ?Sized,
{
    for it in &mut node.attrs {
        v.visit_attribute_mut(it)
    }
    v.visit_path_mut(&mut node.path);
    tokens_helper(v, &mut node.brace_token.span);
    for el in Punctuated::pairs_mut(&mut node.fields) {
        let (it, p) = el.into_tuple();
        v.visit_field_pat_mut(it);
        if let Some(p) = p {
            tokens_helper(v, &mut p.spans);
        }
    }
    if let Some(it) = &mut node.dot2_token {
        tokens_helper(v, &mut it.spans)
    };
}
#[cfg(feature = "full")]
pub fn visit_pat_tuple_mut<V>(v: &mut V, node: &mut PatTuple)
where
    V: VisitMut + ?Sized,
{
    for it in &mut node.attrs {
        v.visit_attribute_mut(it)
    }
    tokens_helper(v, &mut node.paren_token.span);
    for el in Punctuated::pairs_mut(&mut node.elems) {
        let (it, p) = el.into_tuple();
        v.visit_pat_mut(it);
        if let Some(p) = p {
            tokens_helper(v, &mut p.spans);
        }
    }
}
#[cfg(feature = "full")]
pub fn visit_pat_tuple_struct_mut<V>(v: &mut V, node: &mut PatTupleStruct)
where
    V: VisitMut + ?Sized,
{
    for it in &mut node.attrs {
        v.visit_attribute_mut(it)
    }
    v.visit_path_mut(&mut node.path);
    v.visit_pat_tuple_mut(&mut node.pat);
}
#[cfg(feature = "full")]
pub fn visit_pat_type_mut<V>(v: &mut V, node: &mut PatType)
where
    V: VisitMut + ?Sized,
{
    for it in &mut node.attrs {
        v.visit_attribute_mut(it)
    }
    v.visit_pat_mut(&mut *node.pat);
    tokens_helper(v, &mut node.colon_token.spans);
    v.visit_type_mut(&mut *node.ty);
}
#[cfg(feature = "full")]
pub fn visit_pat_wild_mut<V>(v: &mut V, node: &mut PatWild)
where
    V: VisitMut + ?Sized,
{
    for it in &mut node.attrs {
        v.visit_attribute_mut(it)
    }
    tokens_helper(v, &mut node.underscore_token.spans);
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_path_mut<V>(v: &mut V, node: &mut Path)
where
    V: VisitMut + ?Sized,
{
    if let Some(it) = &mut node.leading_colon {
        tokens_helper(v, &mut it.spans)
    };
    for el in Punctuated::pairs_mut(&mut node.segments) {
        let (it, p) = el.into_tuple();
        v.visit_path_segment_mut(it);
        if let Some(p) = p {
            tokens_helper(v, &mut p.spans);
        }
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_path_arguments_mut<V>(v: &mut V, node: &mut PathArguments)
where
    V: VisitMut + ?Sized,
{
    match node {
        PathArguments::None => {}
        PathArguments::AngleBracketed(_binding_0) => {
            v.visit_angle_bracketed_generic_arguments_mut(_binding_0);
        }
        PathArguments::Parenthesized(_binding_0) => {
            v.visit_parenthesized_generic_arguments_mut(_binding_0);
        }
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_path_segment_mut<V>(v: &mut V, node: &mut PathSegment)
where
    V: VisitMut + ?Sized,
{
    v.visit_ident_mut(&mut node.ident);
    v.visit_path_arguments_mut(&mut node.arguments);
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_predicate_eq_mut<V>(v: &mut V, node: &mut PredicateEq)
where
    V: VisitMut + ?Sized,
{
    v.visit_type_mut(&mut node.lhs_ty);
    tokens_helper(v, &mut node.eq_token.spans);
    v.visit_type_mut(&mut node.rhs_ty);
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_predicate_lifetime_mut<V>(v: &mut V, node: &mut PredicateLifetime)
where
    V: VisitMut + ?Sized,
{
    v.visit_lifetime_mut(&mut node.lifetime);
    tokens_helper(v, &mut node.colon_token.spans);
    for el in Punctuated::pairs_mut(&mut node.bounds) {
        let (it, p) = el.into_tuple();
        v.visit_lifetime_mut(it);
        if let Some(p) = p {
            tokens_helper(v, &mut p.spans);
        }
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_predicate_type_mut<V>(v: &mut V, node: &mut PredicateType)
where
    V: VisitMut + ?Sized,
{
    if let Some(it) = &mut node.lifetimes {
        v.visit_bound_lifetimes_mut(it)
    };
    v.visit_type_mut(&mut node.bounded_ty);
    tokens_helper(v, &mut node.colon_token.spans);
    for el in Punctuated::pairs_mut(&mut node.bounds) {
        let (it, p) = el.into_tuple();
        v.visit_type_param_bound_mut(it);
        if let Some(p) = p {
            tokens_helper(v, &mut p.spans);
        }
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_qself_mut<V>(v: &mut V, node: &mut QSelf)
where
    V: VisitMut + ?Sized,
{
    tokens_helper(v, &mut node.lt_token.spans);
    v.visit_type_mut(&mut *node.ty);
    skip!(node.position);
    if let Some(it) = &mut node.as_token {
        tokens_helper(v, &mut it.span)
    };
    tokens_helper(v, &mut node.gt_token.spans);
}
#[cfg(feature = "full")]
pub fn visit_range_limits_mut<V>(v: &mut V, node: &mut RangeLimits)
where
    V: VisitMut + ?Sized,
{
    match node {
        RangeLimits::HalfOpen(_binding_0) => {
            tokens_helper(v, &mut _binding_0.spans);
        }
        RangeLimits::Closed(_binding_0) => {
            tokens_helper(v, &mut _binding_0.spans);
        }
    }
}
#[cfg(feature = "full")]
pub fn visit_receiver_mut<V>(v: &mut V, node: &mut Receiver)
where
    V: VisitMut + ?Sized,
{
    for it in &mut node.attrs {
        v.visit_attribute_mut(it)
    }
    if let Some(it) = &mut node.reference {
        tokens_helper(v, &mut (it).0.spans);
        if let Some(it) = &mut (it).1 {
            v.visit_lifetime_mut(it)
        };
    };
    if let Some(it) = &mut node.mutability {
        tokens_helper(v, &mut it.span)
    };
    tokens_helper(v, &mut node.self_token.span);
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_return_type_mut<V>(v: &mut V, node: &mut ReturnType)
where
    V: VisitMut + ?Sized,
{
    match node {
        ReturnType::Default => {}
        ReturnType::Type(_binding_0, _binding_1) => {
            tokens_helper(v, &mut _binding_0.spans);
            v.visit_type_mut(&mut **_binding_1);
        }
    }
}
#[cfg(feature = "full")]
pub fn visit_signature_mut<V>(v: &mut V, node: &mut Signature)
where
    V: VisitMut + ?Sized,
{
    if let Some(it) = &mut node.constness {
        tokens_helper(v, &mut it.span)
    };
    if let Some(it) = &mut node.asyncness {
        tokens_helper(v, &mut it.span)
    };
    if let Some(it) = &mut node.unsafety {
        tokens_helper(v, &mut it.span)
    };
    if let Some(it) = &mut node.abi {
        v.visit_abi_mut(it)
    };
    tokens_helper(v, &mut node.fn_token.span);
    v.visit_ident_mut(&mut node.ident);
    v.visit_generics_mut(&mut node.generics);
    tokens_helper(v, &mut node.paren_token.span);
    for el in Punctuated::pairs_mut(&mut node.inputs) {
        let (it, p) = el.into_tuple();
        v.visit_fn_arg_mut(it);
        if let Some(p) = p {
            tokens_helper(v, &mut p.spans);
        }
    }
    if let Some(it) = &mut node.variadic {
        v.visit_variadic_mut(it)
    };
    v.visit_return_type_mut(&mut node.output);
}
pub fn visit_span_mut<V>(v: &mut V, node: &mut Span)
where
    V: VisitMut + ?Sized,
{
}
#[cfg(feature = "full")]
pub fn visit_stmt_mut<V>(v: &mut V, node: &mut Stmt)
where
    V: VisitMut + ?Sized,
{
    match node {
        Stmt::Local(_binding_0) => {
            v.visit_local_mut(_binding_0);
        }
        Stmt::Item(_binding_0) => {
            v.visit_item_mut(_binding_0);
        }
        Stmt::Expr(_binding_0) => {
            v.visit_expr_mut(_binding_0);
        }
        Stmt::Semi(_binding_0, _binding_1) => {
            v.visit_expr_mut(_binding_0);
            tokens_helper(v, &mut _binding_1.spans);
        }
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_trait_bound_mut<V>(v: &mut V, node: &mut TraitBound)
where
    V: VisitMut + ?Sized,
{
    if let Some(it) = &mut node.paren_token {
        tokens_helper(v, &mut it.span)
    };
    v.visit_trait_bound_modifier_mut(&mut node.modifier);
    if let Some(it) = &mut node.lifetimes {
        v.visit_bound_lifetimes_mut(it)
    };
    v.visit_path_mut(&mut node.path);
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_trait_bound_modifier_mut<V>(v: &mut V, node: &mut TraitBoundModifier)
where
    V: VisitMut + ?Sized,
{
    match node {
        TraitBoundModifier::None => {}
        TraitBoundModifier::Maybe(_binding_0) => {
            tokens_helper(v, &mut _binding_0.spans);
        }
    }
}
#[cfg(feature = "full")]
pub fn visit_trait_item_mut<V>(v: &mut V, node: &mut TraitItem)
where
    V: VisitMut + ?Sized,
{
    match node {
        TraitItem::Const(_binding_0) => {
            v.visit_trait_item_const_mut(_binding_0);
        }
        TraitItem::Method(_binding_0) => {
            v.visit_trait_item_method_mut(_binding_0);
        }
        TraitItem::Type(_binding_0) => {
            v.visit_trait_item_type_mut(_binding_0);
        }
        TraitItem::Macro(_binding_0) => {
            v.visit_trait_item_macro_mut(_binding_0);
        }
        TraitItem::Verbatim(_binding_0) => {
            skip!(_binding_0);
        }
        _ => unreachable!(),
    }
}
#[cfg(feature = "full")]
pub fn visit_trait_item_const_mut<V>(v: &mut V, node: &mut TraitItemConst)
where
    V: VisitMut + ?Sized,
{
    for it in &mut node.attrs {
        v.visit_attribute_mut(it)
    }
    tokens_helper(v, &mut node.const_token.span);
    v.visit_ident_mut(&mut node.ident);
    tokens_helper(v, &mut node.colon_token.spans);
    v.visit_type_mut(&mut node.ty);
    if let Some(it) = &mut node.default {
        tokens_helper(v, &mut (it).0.spans);
        v.visit_expr_mut(&mut (it).1);
    };
    tokens_helper(v, &mut node.semi_token.spans);
}
#[cfg(feature = "full")]
pub fn visit_trait_item_macro_mut<V>(v: &mut V, node: &mut TraitItemMacro)
where
    V: VisitMut + ?Sized,
{
    for it in &mut node.attrs {
        v.visit_attribute_mut(it)
    }
    v.visit_macro_mut(&mut node.mac);
    if let Some(it) = &mut node.semi_token {
        tokens_helper(v, &mut it.spans)
    };
}
#[cfg(feature = "full")]
pub fn visit_trait_item_method_mut<V>(v: &mut V, node: &mut TraitItemMethod)
where
    V: VisitMut + ?Sized,
{
    for it in &mut node.attrs {
        v.visit_attribute_mut(it)
    }
    v.visit_signature_mut(&mut node.sig);
    if let Some(it) = &mut node.default {
        v.visit_block_mut(it)
    };
    if let Some(it) = &mut node.semi_token {
        tokens_helper(v, &mut it.spans)
    };
}
#[cfg(feature = "full")]
pub fn visit_trait_item_type_mut<V>(v: &mut V, node: &mut TraitItemType)
where
    V: VisitMut + ?Sized,
{
    for it in &mut node.attrs {
        v.visit_attribute_mut(it)
    }
    tokens_helper(v, &mut node.type_token.span);
    v.visit_ident_mut(&mut node.ident);
    v.visit_generics_mut(&mut node.generics);
    if let Some(it) = &mut node.colon_token {
        tokens_helper(v, &mut it.spans)
    };
    for el in Punctuated::pairs_mut(&mut node.bounds) {
        let (it, p) = el.into_tuple();
        v.visit_type_param_bound_mut(it);
        if let Some(p) = p {
            tokens_helper(v, &mut p.spans);
        }
    }
    if let Some(it) = &mut node.default {
        tokens_helper(v, &mut (it).0.spans);
        v.visit_type_mut(&mut (it).1);
    };
    tokens_helper(v, &mut node.semi_token.spans);
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_type_mut<V>(v: &mut V, node: &mut Type)
where
    V: VisitMut + ?Sized,
{
    match node {
        Type::Array(_binding_0) => {
            v.visit_type_array_mut(_binding_0);
        }
        Type::BareFn(_binding_0) => {
            v.visit_type_bare_fn_mut(_binding_0);
        }
        Type::Group(_binding_0) => {
            v.visit_type_group_mut(_binding_0);
        }
        Type::ImplTrait(_binding_0) => {
            v.visit_type_impl_trait_mut(_binding_0);
        }
        Type::Infer(_binding_0) => {
            v.visit_type_infer_mut(_binding_0);
        }
        Type::Macro(_binding_0) => {
            v.visit_type_macro_mut(_binding_0);
        }
        Type::Never(_binding_0) => {
            v.visit_type_never_mut(_binding_0);
        }
        Type::Paren(_binding_0) => {
            v.visit_type_paren_mut(_binding_0);
        }
        Type::Path(_binding_0) => {
            v.visit_type_path_mut(_binding_0);
        }
        Type::Ptr(_binding_0) => {
            v.visit_type_ptr_mut(_binding_0);
        }
        Type::Reference(_binding_0) => {
            v.visit_type_reference_mut(_binding_0);
        }
        Type::Slice(_binding_0) => {
            v.visit_type_slice_mut(_binding_0);
        }
        Type::TraitObject(_binding_0) => {
            v.visit_type_trait_object_mut(_binding_0);
        }
        Type::Tuple(_binding_0) => {
            v.visit_type_tuple_mut(_binding_0);
        }
        Type::Verbatim(_binding_0) => {
            skip!(_binding_0);
        }
        _ => unreachable!(),
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_type_array_mut<V>(v: &mut V, node: &mut TypeArray)
where
    V: VisitMut + ?Sized,
{
    tokens_helper(v, &mut node.bracket_token.span);
    v.visit_type_mut(&mut *node.elem);
    tokens_helper(v, &mut node.semi_token.spans);
    v.visit_expr_mut(&mut node.len);
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_type_bare_fn_mut<V>(v: &mut V, node: &mut TypeBareFn)
where
    V: VisitMut + ?Sized,
{
    if let Some(it) = &mut node.lifetimes {
        v.visit_bound_lifetimes_mut(it)
    };
    if let Some(it) = &mut node.unsafety {
        tokens_helper(v, &mut it.span)
    };
    if let Some(it) = &mut node.abi {
        v.visit_abi_mut(it)
    };
    tokens_helper(v, &mut node.fn_token.span);
    tokens_helper(v, &mut node.paren_token.span);
    for el in Punctuated::pairs_mut(&mut node.inputs) {
        let (it, p) = el.into_tuple();
        v.visit_bare_fn_arg_mut(it);
        if let Some(p) = p {
            tokens_helper(v, &mut p.spans);
        }
    }
    if let Some(it) = &mut node.variadic {
        v.visit_variadic_mut(it)
    };
    v.visit_return_type_mut(&mut node.output);
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_type_group_mut<V>(v: &mut V, node: &mut TypeGroup)
where
    V: VisitMut + ?Sized,
{
    tokens_helper(v, &mut node.group_token.span);
    v.visit_type_mut(&mut *node.elem);
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_type_impl_trait_mut<V>(v: &mut V, node: &mut TypeImplTrait)
where
    V: VisitMut + ?Sized,
{
    tokens_helper(v, &mut node.impl_token.span);
    for el in Punctuated::pairs_mut(&mut node.bounds) {
        let (it, p) = el.into_tuple();
        v.visit_type_param_bound_mut(it);
        if let Some(p) = p {
            tokens_helper(v, &mut p.spans);
        }
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_type_infer_mut<V>(v: &mut V, node: &mut TypeInfer)
where
    V: VisitMut + ?Sized,
{
    tokens_helper(v, &mut node.underscore_token.spans);
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_type_macro_mut<V>(v: &mut V, node: &mut TypeMacro)
where
    V: VisitMut + ?Sized,
{
    v.visit_macro_mut(&mut node.mac);
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_type_never_mut<V>(v: &mut V, node: &mut TypeNever)
where
    V: VisitMut + ?Sized,
{
    tokens_helper(v, &mut node.bang_token.spans);
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_type_param_mut<V>(v: &mut V, node: &mut TypeParam)
where
    V: VisitMut + ?Sized,
{
    for it in &mut node.attrs {
        v.visit_attribute_mut(it)
    }
    v.visit_ident_mut(&mut node.ident);
    if let Some(it) = &mut node.colon_token {
        tokens_helper(v, &mut it.spans)
    };
    for el in Punctuated::pairs_mut(&mut node.bounds) {
        let (it, p) = el.into_tuple();
        v.visit_type_param_bound_mut(it);
        if let Some(p) = p {
            tokens_helper(v, &mut p.spans);
        }
    }
    if let Some(it) = &mut node.eq_token {
        tokens_helper(v, &mut it.spans)
    };
    if let Some(it) = &mut node.default {
        v.visit_type_mut(it)
    };
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_type_param_bound_mut<V>(v: &mut V, node: &mut TypeParamBound)
where
    V: VisitMut + ?Sized,
{
    match node {
        TypeParamBound::Trait(_binding_0) => {
            v.visit_trait_bound_mut(_binding_0);
        }
        TypeParamBound::Lifetime(_binding_0) => {
            v.visit_lifetime_mut(_binding_0);
        }
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_type_paren_mut<V>(v: &mut V, node: &mut TypeParen)
where
    V: VisitMut + ?Sized,
{
    tokens_helper(v, &mut node.paren_token.span);
    v.visit_type_mut(&mut *node.elem);
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_type_path_mut<V>(v: &mut V, node: &mut TypePath)
where
    V: VisitMut + ?Sized,
{
    if let Some(it) = &mut node.qself {
        v.visit_qself_mut(it)
    };
    v.visit_path_mut(&mut node.path);
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_type_ptr_mut<V>(v: &mut V, node: &mut TypePtr)
where
    V: VisitMut + ?Sized,
{
    tokens_helper(v, &mut node.star_token.spans);
    if let Some(it) = &mut node.const_token {
        tokens_helper(v, &mut it.span)
    };
    if let Some(it) = &mut node.mutability {
        tokens_helper(v, &mut it.span)
    };
    v.visit_type_mut(&mut *node.elem);
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_type_reference_mut<V>(v: &mut V, node: &mut TypeReference)
where
    V: VisitMut + ?Sized,
{
    tokens_helper(v, &mut node.and_token.spans);
    if let Some(it) = &mut node.lifetime {
        v.visit_lifetime_mut(it)
    };
    if let Some(it) = &mut node.mutability {
        tokens_helper(v, &mut it.span)
    };
    v.visit_type_mut(&mut *node.elem);
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_type_slice_mut<V>(v: &mut V, node: &mut TypeSlice)
where
    V: VisitMut + ?Sized,
{
    tokens_helper(v, &mut node.bracket_token.span);
    v.visit_type_mut(&mut *node.elem);
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_type_trait_object_mut<V>(v: &mut V, node: &mut TypeTraitObject)
where
    V: VisitMut + ?Sized,
{
    if let Some(it) = &mut node.dyn_token {
        tokens_helper(v, &mut it.span)
    };
    for el in Punctuated::pairs_mut(&mut node.bounds) {
        let (it, p) = el.into_tuple();
        v.visit_type_param_bound_mut(it);
        if let Some(p) = p {
            tokens_helper(v, &mut p.spans);
        }
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_type_tuple_mut<V>(v: &mut V, node: &mut TypeTuple)
where
    V: VisitMut + ?Sized,
{
    tokens_helper(v, &mut node.paren_token.span);
    for el in Punctuated::pairs_mut(&mut node.elems) {
        let (it, p) = el.into_tuple();
        v.visit_type_mut(it);
        if let Some(p) = p {
            tokens_helper(v, &mut p.spans);
        }
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_un_op_mut<V>(v: &mut V, node: &mut UnOp)
where
    V: VisitMut + ?Sized,
{
    match node {
        UnOp::Deref(_binding_0) => {
            tokens_helper(v, &mut _binding_0.spans);
        }
        UnOp::Not(_binding_0) => {
            tokens_helper(v, &mut _binding_0.spans);
        }
        UnOp::Neg(_binding_0) => {
            tokens_helper(v, &mut _binding_0.spans);
        }
    }
}
#[cfg(feature = "full")]
pub fn visit_use_glob_mut<V>(v: &mut V, node: &mut UseGlob)
where
    V: VisitMut + ?Sized,
{
    tokens_helper(v, &mut node.star_token.spans);
}
#[cfg(feature = "full")]
pub fn visit_use_group_mut<V>(v: &mut V, node: &mut UseGroup)
where
    V: VisitMut + ?Sized,
{
    tokens_helper(v, &mut node.brace_token.span);
    for el in Punctuated::pairs_mut(&mut node.items) {
        let (it, p) = el.into_tuple();
        v.visit_use_tree_mut(it);
        if let Some(p) = p {
            tokens_helper(v, &mut p.spans);
        }
    }
}
#[cfg(feature = "full")]
pub fn visit_use_name_mut<V>(v: &mut V, node: &mut UseName)
where
    V: VisitMut + ?Sized,
{
    v.visit_ident_mut(&mut node.ident);
}
#[cfg(feature = "full")]
pub fn visit_use_path_mut<V>(v: &mut V, node: &mut UsePath)
where
    V: VisitMut + ?Sized,
{
    v.visit_ident_mut(&mut node.ident);
    tokens_helper(v, &mut node.colon2_token.spans);
    v.visit_use_tree_mut(&mut *node.tree);
}
#[cfg(feature = "full")]
pub fn visit_use_rename_mut<V>(v: &mut V, node: &mut UseRename)
where
    V: VisitMut + ?Sized,
{
    v.visit_ident_mut(&mut node.ident);
    tokens_helper(v, &mut node.as_token.span);
    v.visit_ident_mut(&mut node.rename);
}
#[cfg(feature = "full")]
pub fn visit_use_tree_mut<V>(v: &mut V, node: &mut UseTree)
where
    V: VisitMut + ?Sized,
{
    match node {
        UseTree::Path(_binding_0) => {
            v.visit_use_path_mut(_binding_0);
        }
        UseTree::Name(_binding_0) => {
            v.visit_use_name_mut(_binding_0);
        }
        UseTree::Rename(_binding_0) => {
            v.visit_use_rename_mut(_binding_0);
        }
        UseTree::Glob(_binding_0) => {
            v.visit_use_glob_mut(_binding_0);
        }
        UseTree::Group(_binding_0) => {
            v.visit_use_group_mut(_binding_0);
        }
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_variadic_mut<V>(v: &mut V, node: &mut Variadic)
where
    V: VisitMut + ?Sized,
{
    for it in &mut node.attrs {
        v.visit_attribute_mut(it)
    }
    tokens_helper(v, &mut node.dots.spans);
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_variant_mut<V>(v: &mut V, node: &mut Variant)
where
    V: VisitMut + ?Sized,
{
    for it in &mut node.attrs {
        v.visit_attribute_mut(it)
    }
    v.visit_ident_mut(&mut node.ident);
    v.visit_fields_mut(&mut node.fields);
    if let Some(it) = &mut node.discriminant {
        tokens_helper(v, &mut (it).0.spans);
        v.visit_expr_mut(&mut (it).1);
    };
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_vis_crate_mut<V>(v: &mut V, node: &mut VisCrate)
where
    V: VisitMut + ?Sized,
{
    tokens_helper(v, &mut node.crate_token.span);
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_vis_public_mut<V>(v: &mut V, node: &mut VisPublic)
where
    V: VisitMut + ?Sized,
{
    tokens_helper(v, &mut node.pub_token.span);
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_vis_restricted_mut<V>(v: &mut V, node: &mut VisRestricted)
where
    V: VisitMut + ?Sized,
{
    tokens_helper(v, &mut node.pub_token.span);
    tokens_helper(v, &mut node.paren_token.span);
    if let Some(it) = &mut node.in_token {
        tokens_helper(v, &mut it.span)
    };
    v.visit_path_mut(&mut *node.path);
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_visibility_mut<V>(v: &mut V, node: &mut Visibility)
where
    V: VisitMut + ?Sized,
{
    match node {
        Visibility::Public(_binding_0) => {
            v.visit_vis_public_mut(_binding_0);
        }
        Visibility::Crate(_binding_0) => {
            v.visit_vis_crate_mut(_binding_0);
        }
        Visibility::Restricted(_binding_0) => {
            v.visit_vis_restricted_mut(_binding_0);
        }
        Visibility::Inherited => {}
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_where_clause_mut<V>(v: &mut V, node: &mut WhereClause)
where
    V: VisitMut + ?Sized,
{
    tokens_helper(v, &mut node.where_token.span);
    for el in Punctuated::pairs_mut(&mut node.predicates) {
        let (it, p) = el.into_tuple();
        v.visit_where_predicate_mut(it);
        if let Some(p) = p {
            tokens_helper(v, &mut p.spans);
        }
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
pub fn visit_where_predicate_mut<V>(v: &mut V, node: &mut WherePredicate)
where
    V: VisitMut + ?Sized,
{
    match node {
        WherePredicate::Type(_binding_0) => {
            v.visit_predicate_type_mut(_binding_0);
        }
        WherePredicate::Lifetime(_binding_0) => {
            v.visit_predicate_lifetime_mut(_binding_0);
        }
        WherePredicate::Eq(_binding_0) => {
            v.visit_predicate_eq_mut(_binding_0);
        }
    }
}
